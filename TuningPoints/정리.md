# Top N 쿼리
  - row_number
  - rownum 사용(뷰 머징 방지)
  - 얇게 일기 + rowid 이용하기
  - use_nl 조인 권장

# Not 조건 -> 인덱스 스캔 가능 조건으로 변경
  - in 조건으로 반경
  - or 조건으로 변경(/*+ use_concat */)
  - Union all 로 분기 처리
  - 부등호 조건으로 변경 ('abc' > a or 'abc' < a)

# 옵션처리
  - 옵션 컬럼 Not Null -> nvl 함수
  - 옵션 컬럼 Null -> Union all 사용 컬럼 기준 분기

# 실행 계획 
  - Row 컬럼의 위 아래 값 차이 -> 컬럼 추가
  - Row 건수 에 비해 읽은 블록수가 많으면 -> 컬럼 순서 조정
  - 비 상관 스칼라 쿼리 -> 먼저 실행 -> 메인 쿼리 수행
  - 상관 스칼라 쿼리 -> 메인 쿼리 실행 -> 스칼라 쿼리 실행
  - 스칼라 쿼리 값 x -> Null 출

# 쿼리의 목적
  - 집합적 사고 필요
  - 쿼리의 의미를 파악해야됨

# 쿼리 블록 설정
  - 뷰 -> /*+ qb_name(subq) */
  - 메인 -> /*+ TableName@(subq) */

# 결과 집합
  - 전체 건수에 비해 결과집합이 5~10%이상일 경우 full 이용이 유용하다.
  - 결과 건수가 많을 수록 조인 횟수를 줄여야함
  - no_nlj_batching (batch I/O 예방)

# 부분 범위 처리
  - no_merge push_pred
  - sort 생략 Index , Index_desc (order by + 컬럼 desc) 일경우

# Index_ffs
  - 인덱스 컬럼만 조회(where, group by, order by도 포함
  - 순서 보장 안함(Multiblock I/O)

# Outer Join 
  - 조인 조건에 (+)이 있는 컬럼이 Null 이 나올 가능성 있는 컬럼

# 오라클 하루 연산
  - 1(60*60*24)

# 데이터 비율
  - 조인 테이블간 데이터 비율 1:2 일 경우 -> nl_sj 형식의 비효율 발생 가능성

# 데이터 분포가 고르지 않은 경우
  - Union 으로 데이터 별 분기 처리

# 파티션 
  - Partition Range ALl -> Pruning 조건 사용

# Order by 
  - order by 컬럼이 가공 되면 비효율 발생
  - 결과 집합이 적으면 order by가 의미 없음
  - 그룹핑 전 조인 -> 그룹핑 대상 감소 : 불필요한 그룹핑 대상이 많을경우
  - 그룹핑 먼저 -> 조인 횟수 : 불필요한 조인 많을 경우

# Index
  - Index 추가 -> DML 부하 발생 가능
  - Index 순서 -> NDV가 높은 순으로 구성 (변별력이 높은 순)

# 조인 횟수
  - 불필요한 조인 제거 (select 안의 조회 컬럼이 특정 테이블만 조회시 / 쿼리상 조인을 제거해도 문제 없을 경우)

# 범위 조건
  - 시작과 종료 중 탐색범위 예상 : 범위가 작은 것을 Index에 추가, 또는 인덱스 구성 컬럼으로..

# IN 조건의 컬럼
  - 필터 조건으로 인덱스 구성
  - 선두 컬럼 지정시 수직 탐색 반복 (Index_ss 사용시 문제 X)

# 인덱스 스캔 범위 
  - 배타적으로 구성후 + Union all 처리 -> 효율적임

# NL 조인 
  - Rownum, row_number(partition 내 1건만 따로 추출 시), Top N 처리 시 유리

# 결과 집합이 많은 경우
  - 먼저 결과 집합 처리 -> 서브 정보 조인

# Not exists -> hash_aj 힌트 이용

# no_unnest
  - select의 서브쿼리 Top 1, StopKey 사용할경우(rownum = 1) no_unnest 사용이 유효하다

# like 조건
  - 옵션 조건 -> 입력X -> 인덱스 Full Scan

# Granule 단위
  - 병렬로 2 or 4 또는 문제 내 병렬 로 사용
  - index_ffs 도 Granule 사용

# Partition 단위
  - 파티션 갯수만 큼 병렬도 사용

# nvl2(expr1, expr2, expr3)
  - expr1이 null -> expr2
  - expr1이 null X -> expr3

# 불필요한 힌트, 불필요한 인덱스 컬럼 -> 비효율 발생 될수 있음
