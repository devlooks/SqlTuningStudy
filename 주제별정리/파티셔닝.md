파티셔닝
    - 파티션 키에 따라 논리적으로 분할되고 물리적으로는 별도 세그먼트에 저장
    - 관리적 측면 : 파티션 단위로 백업, 추가, 삭제, 변경 가능 → 유지보수 편의, 데이터 가용성 향상
    - 성능적 측면 : 파티션 단위 SELECT 및 DML 가능 → 병렬 처리, I/O 분산, 락 경합 완화
    - 대용량 이력 테이블의 수명주기(Lifecycle) 관리에 효과적 (예: 월별 보관/폐기)

HASH 파티셔닝
    - 파티션 키에 해시 함수 적용 → 균등 분산되어 특정 파티션에 몰림 방지
    - 조건절에 등치(=), IN-List 조건 사용 시 Partition Pruning 작동
    - 데이터 분포가 균일하지 않으면 특정 파티션 부하 집중 → 주기적 skew 분석 권장
    - 병렬 DML, 병렬 조인(PWJ) 시 효과적
    - 해시 파티션 수는 2의 제곱수 사용 권장 (8, 16, 32 등)

LIST 파티셔닝
    - 사용자 정의의 불연속 값 그룹 기준으로 데이터 분할
    - 단일 컬럼 파티션 키만 지정 가능
    - 반드시 DEFAULT 파티션을 생성해야 예외 값 수용 가능
    - 지역코드, 상태값 등 도메인별 조건 분리 및 관리에 유리

List : 사용자 정의 불연속 값 목록
Range : 정렬 가능한 값의 순서
Hash : 해시 함수를 통한 균등 분산

결합 파티셔닝 (Composite Partitioning)
    - 두 종류의 파티셔닝 기법을 조합 (예: Range-Hash, List-Hash 등)
    - 각 서브 파티션마다 독립적인 세그먼트 할당
    - 병렬 처리 성능 극대화 (Partition-wise Join 가능)
    - 예: 월별 RANGE + 고객 ID HASH → 이력 데이터 + 병렬 조회 모두 만족

파티션 Pruning
                    Pstart  Pstop
- 정적 Pruning     숫자    숫자       → 컴파일 시점에 조건값이 명확
- 동적 Pruning     key     key        → 실행 시점에 바인드 변수 등으로 결정
주의사항
    - 파티션 키에 함수, 형변환, 산술연산 적용 시 Pruning 작동 안 됨
    - LIKE, IS NULL, != 조건 사용 시 프루닝 실패 위험
    - MAXVALUE 파티션 반드시 지정 → 예외 또는 미래 값 수용
    - EXPLAIN PLAN 또는 DBMS_XPLAN.DISPLAY_CURSOR로 Pstart/Pstop 확인 필수

인덱스 파티셔닝

local Partitioned Index
    - 파티션과 1:1 관계를 맺음 (테이블 파티션 단위로 관리)
    - 테이블 파티션 변경 시 인덱스 자동 반영
    - 인덱스 재생성 불필요, 병렬 인덱스 rebuild 가능
    - 병렬 처리, DDL 작업 시 성능 관리에 유리

Global Partitioned Index
    - 테이블 파티션과 독립된 인덱스 파티셔닝 구조
    - 테이블 파티션 DROP 시 인덱스 UNUSABLE 상태 전환 가능
    - 효율성 저하 방지 위해 사용 후 반드시 REBUILD 필요
    - 고성능 조회에 유리하나 유지보수 주의

Non-Partitioned Index
    - 파티션 테이블에 대해 단일 인덱스 구성 (1:M)
    - 파티션 변경 시 전체 인덱스 재생성 필요
    - OLTP 환경에서는 성능상 유리한 경우 존재

Prefixed vs NonPrefixed
    - Prefixed: 인덱스 선두 컬럼에 파티션 키 포함 → 파티션 Pruning + Index Seek 가능
    - NonPrefixed: 인덱스 선두 컬럼에 파티션 키 없음 → Pruning 안 되며 Index Full/Range Scan 발생
    - 실무 적용: 이력 테이블 또는 BETWEEN 조건 많은 환경에서는 NonPrefixed도 고려

local-NonPrefixed Index
    - 이력성 데이터 관리에 적합
    - BETWEEN, RANGE 조건으로 성능 확보 가능
    - 파티션 Pruning은 되지 않으나 인덱스 스캔 효율 높음

Partitioned Index
    - WHERE 절에 파티션 키가 없으면 전체 파티션 조회 발생
    - 실행계획에 PARTITION RANGE ALL / LIST ALL로 표시됨
    - 반드시 파티션 키 포함 조건 설계 필요

액세스 효율 고려 파티셔닝 선택 기준
    - DW/DSS 환경 → Composite 또는 Local Prefixed Index가 병렬성과 유지보수에 유리
    - OLTP 환경   → 응답 속도, 인덱스 효율 고려 시 Non-Partitioned Index가 유리하나,
                    관리 편의와 병렬성을 위해 Local Partitioned Index도 적극 고려됨
