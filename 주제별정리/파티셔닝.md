
파티셔닝
  - 파티션 키 기준 논리적 분할, 별도 세그먼트 저장
  - 관리적 측면: 백업, 추가, 삭제, 변경 등 파티션 단위 관리 가능
  - 성능적 측면: 병렬 처리, 경합 감소, I/O 분산
  - 대용량 이력 테이블 Life Cycle 관리에 유리

HASH 파티셔닝
  - 해시 함수로 균등 분산
  - =, IN 조건 시 파티션 Pruning 가능
  - 데이터 분포 skew 발생 가능 → 파티션 키 선정 중요
  - 병렬 Insert, 병렬 Join 효과
  - 파티션 수는 2의 제곱수 권장 (예: 8, 16, 32)

LIST 파티셔닝
  - 사용자 정의 불연속 값 기준
  - 단일 컬럼만 가능
  - DEFAULT 파티션 필수 (예외 값 수용)
  - 지역, 상태 코드, 카테고리 값 구분에 적합

파티셔닝 유형 요약
  - List: 사용자 정의 불연속 값 목록
  - Range: 정렬 가능 값의 범위
  - Hash: 내부 해시 함수 기반 분산

결합 파티셔닝 (Composite)
  - Range + Hash, List + Hash 등 조합
  - 서브 파티션 단위 세그먼트 저장
  - Partition-wise Join, 병렬 처리 최적화

파티션 Pruning
  - 정적 Pruning: Pstart/Pstop = 숫자 (리터럴 조건)
  - 동적 Pruning: Pstart/Pstop = key (바인드 변수/서브쿼리 조건)
  - 주의사항:
    - 함수/연산/형변환 시 Pruning 실패
    - LIKE, IS NULL, != 조건은 비권장
    - MAXVALUE 파티션 반드시 지정

인덱스 파티셔닝

    Local Partitioned Index
        - 파티션 1:1 대응
        - 자동 반영, 인덱스 재생성 불필요
        - 병렬 Rebuild 가능
        - DW/DSS 환경 적합
    
     Global Partitioned Index
        - 테이블 파티션과 독립
        - DROP/MERGE 시 UNUSABLE 상태 발생
        - 재사용 시 ALTER INDEX REBUILD 필요
    
     Non-Partitioned Index
        - 테이블 전체 대상 단일 인덱스
        - 변경 시 전체 재생성 필요
        - OLTP에서 응답속도 우위

Prefixed vs NonPrefixed
  - Prefixed: 파티션 키가 선두 → Pruning + Index Seek 가능
  - NonPrefixed: 파티션 키가 후순위 → Pruning 불가, Index Scan만 가능

Local Non-Prefixed Index
  - 이력성 테이블에 적합
  - BETWEEN, RANGE 조건 시 Index Scan 효율적
  - Pruning은 안 되나 성능 확보 가능

Partitioned Index
  - WHERE절에 파티션 키 없으면 전체 스캔
  - 실행계획: Partition Range All / List All
  - 설계 시 파티션 키 포함 필수

파티셔닝 선택 기준
  - DW/DSS:
    - Composite or Local Prefixed Index → 병렬 처리 및 유지 관리 유리
  - OLTP:
    - 응답속도 우선 시 Non-Partitioned Index
    - 병렬성과 관리성 고려 시 Local Index 우선 고려
