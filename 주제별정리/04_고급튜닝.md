
## 인덱스
- 범위 조건 컬럼 ⇒ 인덱스 마지막 ⇒ 효율이 좋음
- 인덱스 수평 탐색 시작 지점  
  - 등치 + 범위 ⇒ 등치조건 + 범위조건 시작지점
- 숫자 + LIKE 조건 ⇒ 형변환 Index Scan 불가
- IN 조건 ⇒ 형변환 불가
- 인덱스 구성: NDV 높은 순 + 조건절에서 자주 사용 순으로
- 클러스터링 팩터가 나쁜 상태: 테이블 엑세스 I/O = 블록 I/O  
  (인덱스 블록 스캔 < 레코드 수 ⇒ 비효율 적음)
- CR(CURRENT READ)와 ROWS 수치 차이에서 CR이 더 높으면 인덱스 추가로 비효율 감소 가능
- 인덱스 추가 ⇒ 수평 탐색(인덱스) 범위 줄이고 ⇒ 테이블(Random) 엑세스 량도 감소
- 인덱스 선택 기준 ⇒ 자주 사용, 등치 조건, NDV가 높음  
  - [보완] 함수 기반 인덱스(Function Based Index)·비트맵 인덱스(저변경/대량질의)·IOT 고려. 통계에 히스토그램 적용으로 Skew 대응.

## 조인 튜닝
- 엑세스 테이블 처리 범위 ⇒ 전체 처리량 결정 ⇒ NL 조인
- 테이블 검색 조건 ⇒ 전체 일의 량 결정 ⇒ Merge Sort 조인
- Full Partition Wise Join ⇒ `/*+ pq_distribute(B, NONE, NONE) */`
- Partial Partition Wise Join ⇒  
  - `/*+ PQ_distribute(B, Partition, NONE) */`  
  - `/*+ PQ_distribute(B, NONE, Partition) */`
- Build Input ⇒ PGA, Hash Area 저장  
  ⇒ Hash 키 컬럼(Build Input)에 중복값 거의 없을 때 성능 우수
- Exists절 ⇒ Semi Join
- Sort Merge Join  
  - NL 조인 비효율 시 선택  
  - Driving Table 개념 중요 X  
  - 조인 조건의 인덱스 상관 X 경우
- Hash Join 효과적인 경우  
  - Natural Join 비효율일 경우  
  - Driving 집합 조인 엑세스 많고, Random Access 적을 경우  
  - Sort Merge 부하 높고, Sort 부하가 큰 경우  
  - 수행빈도 낮음  
  - 쿼리 수행시간이 김  
  - 한쪽 테이블 결과집합이 메모리에 적합할 때  
  - 조인 컬럼에 중복값 거의 없을 때  
  - [보완] Hash Build 입력은 작고 중복 적을수록 유리, Spill 발생 시 TEMP I/O 급증. Partition-wise 조인으로 재분배(Shuffle) 비용 절감.

## 스칼라 서브쿼리
- 순차적 실행
- 하나의 값 리턴
- 조인 안 되면 NULL 반환
- PGA에 캐싱  
  - [보완] 상수화 가능한 서브쿼리는 매칭 시 캐시 히트율 증가, 하지만 상호상관(Correlated) 시 호출 수 증가.

## 선분이력 (Group By 인라인뷰 조인)
- 반대편 결과 집합 데이터량이 적을수록 비효율  
  ⇒ Group By 결과집합이 적음(대량 필터링)  
  - [보완] 선분 교차(기간 조인)는 GTT/윈도우 함수나 Range 파티셔닝으로 대체 고려.

## CBO (NDV)
- SQL 실행 ⇒ 처리시간 및 CPU, I/O 자원량 계산 ⇒ 최적 예상 계획  
  - [보완] 바인드 스니핑, 적응적 플랜(Adaptive), SQL Plan Baseline/Outline로 안정화 가능.

## 커서 캐싱
- 캐싱된 커서(SQL) 반복 재사용, 여러 세션 간 공유
- 동일 SQL (실행계획 - library Cache 공유)
- 상이한 SQL (하드파싱 발생)  
  - [보완] 커서 쉐어링 위해 바인드 변수 사용 권장. 커서 피닝/세션 캐시 커서로 파싱 부하 절감.

## Literal 상수조건 사용
- 수행빈도 낮고, 1회 실행이 오래 걸릴 때
- 컬럼 값 종류 소수, 분포 균일하지 않을 때
- 조회 항목이 고정될 때  
  - [보완] 바인드 피킹 이슈 회피 목적. 빈도↑이면 바인드+히스토그램, SQL 프로파일/플랜 관리 활용.

## Static vs Dynamic SQL
- Static SQL: 문자열 변수 없이 코드 내 직접 기술 → 권장
- Dynamic SQL: 문자열 변수로 실행  
  - [보완] Static은 컴파일·검증 장점. Dynamic은 유연하나 파싱/보안 주의.

## CBO 비용 기준
- I/O 일량
- CPU·디스크 속도
- I/O + CPU 연산 비용  
  - [보완] 병렬 비용·카디널리티 추정·조인순서 탐색 비용 포함.

## ALL_ROWS
- Throughput 중심
- 결과 집합 끝까지 Fetch 전제
- Full Scan 가능
- 전체 범위 최적화 방식  
  - [보완] 대량 배치·리포팅 적합. 대화형은 FIRST_ROWS 계열 고려.

## 통계정보 수집시 고려사항
- 시간/주기: 저부하 시간대
- 정확성: 표본 vs 전수
- 안정성: 빈번 변경 지양  
  - [보완] 증분 통계·파티션 통계·히스토그램 관리.

## View Merging
- Group By 포함 뷰는 자주 Merging 발생  
  - 예시:  
    ```
    select ~
    from (
        select ~
        union
        select ~
    )
    where deptno = ~
    ```
    ⇒ deptno 조건이 뷰 내부로 이동
- Merging 불가능: 집합연산자, Connect By, ROWNUM  
  - [보완] 분석함수·Distinct·Outer Join 확장도 제한 발생 가능.

## ArraySize 트레이스
- 예시:  
  ```
  count    ~     Rows
  Parse     1      0
  Execute   1      0
  Fetch   301  30000
  ```
  ⇒ 30000 / (301-1) = Fetch 당 100건  
  - [보완] Array Size 조정으로 네트워크 왕복/Fetch 호출 수 절감 가능.

## 사용자 정의 함수 / 스칼라 서브쿼리
- WHERE 조건절 만큼 반복 호출
- 스칼라 서브쿼리: 호출 횟수 적음(캐싱)
- 함수 내 SQL ⇒ Recursive Call 발생
- Context Switching 부하 증가
- 값 종류 많음 ⇒ 사용자 정의 함수
- 값 종류 적음 ⇒ 스칼라 서브쿼리
- 참조 테이블 값 변경 시 결과 변경  
  - [보완] UDF는 Deterministic 선언·RESULT_CACHE(버전 지원 시) 활용.

## Local 파티션 인덱스
- 테이블 파티션과 1:1 대응
- ADD/DROP/SPLIT/EXCHANGE 시 인덱스 파티션 자동 관리
- 파티션 키 조건절 미사용 시 비효율  
  - [보완] Global Index는 파티션 변경 시 유지보수 비용↑.

## 파티셔닝
- List: 그룹 기준 (예: 지역)
- Range: 키 값 범위
- Hash: 해시 함수, 분포 균등, 병렬 효율↑, DML 경합 분산
- Composite: Range+List, 장점 결합  
  - [보완] 프루닝 가능성·DML 경합 분산·병렬성 관점에서 선택.

## Sort Operation
- Sort Aggregate: 전체 로우 대상, 실제 Sort X
- Sort Order by: 정렬된 결과 집합
- Sort Group by: 그룹별 집계
- Sort Unique: 중복 제거
- Sort Join: Sort Merge 조인
- Window Sort: 윈도우 함수  
  - [보완] PGA 부족 시 Temp Spill. Workarea 정책(자동/수동) 점검.

## Union All / Union
- PK 있으면 상호 배타적 관계  
  - [보완] UNION은 Distinct 포함(정렬/해시), UNION ALL은 병합만. PK/분할 규칙으로 중복 제거 생략 가능.

## ROWNUM 주의
- ROWNUM 위치에 따라 결과 달라짐 ⇒ 반드시 ORDER BY 후 사용  
  - [보완] 12c 이상은 FETCH FIRST … ROWS, OFFSET … FETCH 권장.

## PQ_DISTRIBUTE 힌트
- 양쪽 테이블 동적 파티셔닝 ⇒ `PQ_DISTRIBUTE(o, hash, hash)`  
  - [보완] 양측 해시 분배로 균등화, Skew 시 해시 키 개선/Salting 고려.

## APPEND + Insert
- `/*+ APPEND */` + Insert ⇒ TM Lock 설정  
  - [보완] Direct-path insert는 TM 잠금 수준 상승 가능.

## NOLOGGING
- NOLOGGING ⇒ Redo Log 미사용
- APPEND ⇒ Undo 미사용, Freelist 조회 X, HWM 뒤쪽 순차 입력  
  - [보완] 복구 불가 위험 감수(백업·체크포인트 전략 필수). HWM 뒤로 순차 I/O 효과.

## DML 튜닝 방안
- 인덱스 Unusable ⇒ 재생성
- NOLOGGING ⇒ Insert
- Update/Delete ⇒ 임시테이블로 조정 ⇒ Truncate ⇒ 재입력  
  - [보완] MERGE로 다단계 DML 축약. 병렬 DML 시 제약/잠금 주의.

## 배치 프로그램 속도 향상
- 인덱스 제거 후 재생성
- 수정 가능한 조인뷰 + Merge
- SQL Server 최소 로깅 Insert  
  - [보완] 파티션 교체(Exchange Partition)·외부 테이블 로드 후 스위치.

## 인덱스 파티셔닝 단점
- 저장 효율 저하  
  - [보완] 관리성/프루닝 이점과 저장효율의 트레이드오프 평가.

## 파티션
- 인덱스 파티셔닝 ⇒ 일부 SQL 성능 하락 가능성
- 파티션 단위 인덱스 재생성  
  - [보완] Local/Global 혼용 설계로 질의 패턴별 균형.

## 파티션 인덱스 비효율
- 타입 변동
- 컬럼 값 가공
- 반복 액세스  
  - [보완] 표현식 동일성 보장(함수 기반 인덱스), 암시적 변환 방지.

## 배치 프로그램 튜닝
- 전체 처리 속도 최적화
- 개별보다 전체 기준
- 병렬 처리
- 공통 집합 임시테이블
- 동시 수행 X (Lock 발생)  
  - [보완] 분할정복(시간/키 범위), 리소스 매니저로 자원 격리.

## 병렬 프로세스
- 처리 과정 모두 병렬
- 통신량 최소
- 병렬 DML ⇒ TM Lock 주의  
  - [보완] PX 도플로이·분배 정책(BROADCAST/HASH/NONE)으로 스큐·통신 절감.

## Lock 경합 개선
- 트랜잭션 짧게
- 동시 수행 자제
- SELECT FOR UPDATE 자제
- DML 인덱스 최적화  
  - [보완] 키 범위 축소, 배치 시간 분산, Lock/Enqueue 대기 분석.

## SQL Server Lock 특성
- Share Lock과 Exclusive Lock 호환 X ⇒ SELECT도 블로킹  
  - [보완] RCSI/Snapshot 사용 시 읽기 차단 완화.

## SQL Server 힌트
- forceseek: Index Seek 강제
- ReadPast: Lock 행 읽지 않음
- Table Lock: 테이블 레벨 Lock  
  - [보완] READPAST 힌트, TABLOCK/TABLOCKX 주의, 힌트 남용 시 플랜 고착 위험.

## Isolation Level & Read 현상
- Dirty Read, Non-Repeatable Read, Phantom Read 정의  
  - [보완] 현상은 Isolation Level에 따라 발생 여부 다름.
- Read Uncommitted / Read Committed / Repeatable Read / Serializable  
  - 대부분 DBMS 기본: Read Committed  
  - [보완] Oracle 기본은 Read Committed(MVCC), SQL Server도 Read Committed가 일반적.

## 트랜잭션 동시성 제어
- 비관적(읽을 때 잠금)
- 낙관적(검증 시 충돌 감지)
- Serializable  
  - [보완] 타임스탬프/버전 기반 검증, 재시도 로직 필요.

## Oracle vs SQL Server DML 잠금
- Oracle: DML 시작 시 대상 레코드 식별
- SQL Server: DML 종료까지 대기  
  - [보완] Oracle은 Undo 기반 일관성 뷰 제공, SQL Server는 잠금 기반(RCSI/Snapshot 예외).

## MVCC
- 문장 수준 일관성 완벽 보장
- 트랜잭션 수준 일관성 보장 X
- Undo Segment 사용
- 트랜잭션 수준 일관성 ⇒ REPEATABLE READ 이상  
  - [보완] Oracle은 Flashback Query/Version으로 시점 조회 가능.

## 시험 포인트 요약
1. 파티션 테이블  
   - 파티션 프루닝  
   - 그룹핑으로 대상 감소  
   - 스칼라 함수 호출 수 감소  
   - SUM 집계 후 조인
2. ORDER BY ⇒ ROWNUM ⇒ 조인 ⇒ 조건 ⇒ 마지막 ORDER BY  
   - 인덱스(특히 _desc)로 Sort 생략
3. 인덱스 활용성  
   - WHERE에 OR 지양  
   - LIKE 변환·함수 가공 지양(형변환 시 Range Scan 불가)
4. 페이징  
   - 안쪽 뷰에서 ORDER BY  
   - 바깥에서 ROWNUM  
   - [보완] 12c+: OFFSET … FETCH 권장
5. 병렬 쿼리  
   - 대량 데이터·해시·멀티블록 I/O  
   - 세션 설정: `alter session enable parallel dml;`  
   - 동적 파티셔닝: `PQ_DISTRIBUTE(o, hash, hash)`

**병렬 쿼리 예시**
```
insert /*+ parallel(t 4) */ into ~
select /*+ leading(d) use_hash(o) use_hash(c) full(o) full(d) index_ffs(c)
            parallel(o 4) parallel(d 4) parallel_index(c 4) */
~
from 주문 o, 배송 d, 고객 c
where ~ (파티션 프루닝)
and   ~ (조인 조건, o, d)
and   ~ 배송일자 범위
and   ~ (조인 조건, d, c)
```
