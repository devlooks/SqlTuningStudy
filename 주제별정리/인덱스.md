# 인덱스 

## 인덱스 구조

- Root, Branch → 하위 블록을 가리키는 주소값 저장  
  - 브랜치 노드갓의 키 값은 하위 노드의 값의 범위  
- Leaf → 테이블 레코드를 가리키는 주소값 저장  
  - 리프 노드, 테이블 레코드 키값을 서로 일치  
  - 리프 노드 끼리, 이중연결 리스트

## 인덱스 탐색

- 수직적 탐색: 인덱스 스캔 시작지점 (시작지점 못 찾으면 Index Full Scan)  
- 수평적 탐색: 데이터 찾는 과정 (좌→우, 우→좌) (이벤트: Sequential / Scattered)

## Range Scan 불가 조건

1. 중간 값 스캔 (LIKE 조건)  
2. 인덱스 컬럼 가공 (인덱스 컬럼 편집)  
3. 부정형 비교 (IS NOT, <> 등등)  
4. OR 비교 (OR-expansion 안됨)  
5. 인덱스 선두컬럼 조건절 누락  

> 인덱스 범위 스캔은 하지만 스캔 범위를 줄이지 못함:  
> → 인덱스 선두 조건 + 나머지 인덱스 컬럼이 Range Scan 못하는 상태

## 인덱스 소트 연산 생략

- ORDER BY + 인덱스 컬럼  
- MIN/MAX 의 인자 컬럼 + 인덱스 컬럼  
  - 실행계획: First Row + (MIN/MAX) 출력됨

## 인덱스 스캔 방식

### Index Full Scan

- 조건절에 인덱스 컬럼이 존재하나, 범위를 줄이지 못해 모든 Index를 읽어야 할 때 사용

### Table Full Scan

- 조건절에 인덱스가 없어, Table을 전부 읽어야 할 때 사용

### Index Skip Scan

- 조건절에 빠진 인덱스 선두컬럼의 변별력이 낮을 때  
- 후행 컬럼의 변별력이 높을 때

#### Index Skip Scan 작동 조건

1. 인덱스 선두컬럼 누락  
2. Distinct Value가 적은 두 개의 선두컬럼 모두 누락  
3. 인덱스 중간 컬럼 누락  
4. 선두컬럼이 범위 조건일 경우

### Index Fast Full Scan

- MultiBlock I/O  
- 순서대로 정렬 안됨  
- 병렬쿼리 가능  
- 쿼리 모든 컬럼이 인덱스에 포함 (SELECT, 조건절)

## ROWID 구성

- 논리 주소 (데이터 파일번호, 오브젝트 번호, 블록 번호 등...)

## 클러스터링 팩터

- 데이터가 서로 모여있는 정도  
- 좋으면 인덱스 효율이 올라감

## 인덱스 컬럼 추가 효과

- Random I/O (Table Access) 줄임  
- 클러스터링 팩터는 안 좋아짐  
- 인덱스 Depth 증가  
- GROUP BY 시 인덱스만 읽고 처리할 수 있음

## 배치 I/O

- 테이블 레코드를 액세스 버퍼캐시에서 못 찾을 때, 일정량을 모아서 처리  
- MultiBlock I/O  
- 클러스터링 팩터가 나쁠 때 효과적  
- Random Access 성능 향상  
- 버퍼캐시 히트율 100% → 기존과 동일한 정렬 순서 보장 → ORDER BY 필요

## 테이블 유형

### Heap-Organized Table

- Freelist로부터 할당 받은 블록에 정해진 순서 없이 값 입력

### Index-Organized Table (IOT)

- 데이터를 삽입할 때 정렬 상태를 유지하는 인덱스 구조 테이블

#### 장점

- 넓은 범위 검색 시 유리 (Sequential)  
- 저장 공간 절약 (PK 별도 세그먼트 생성 안함)

#### 단점

- Direct Path Insert 작동 안함

#### 사용 적합 예

- 크기 작고, NL 조인 반복 Lookup  
- 폭이 좁고 긴 (=로우 수 많은) 테이블  
- BETWEEN, LIKE 조건으로 넓은 범위 주로 검색되는 통계성 테이블  
- 데이터 입력과 조회 패턴이 서로 다른 테이블

#### Secondary 인덱스

- 주기적인 ROWID 갱신 부담  
- PK 중복 저장에 따른 공간 부담

#### IOT 도입 시 주의사항

- 비 휘발성 IOT 아니면 Secondary 인덱스가 많지 않아야 함  
- 조회 패턴이 다양해서 Secondary 인덱스가 많이 필요한 경우:
  - PK 구조 가볍게  
  - 주기적인 ROWID 갱신 고려

## 인덱스 효율

- 인덱스 조건 중 범위검색 조건까지 만족하는 인덱스 레코드까지 연속되게 모여 있음  
- 그 이하의 조건의 인덱스 컬럼은 흩어져 있음

## Between → IN-List 변환 주의사항

- IN-List 갯수 많이 않아야 함  
- 인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때  
- 선택 레코드가 소량일 때

## IN 조건은 = 조건인가?

- IN은 IN-List Iterator 방식으로 풀려야 등치가 됨

## 인덱스 사용 조건

- 인덱스 선두컬럼이 조건절에 있어야 한다  
- 인덱스 선두 컬럼에 대한 가공, 중간값 검색, 부정형 비교 등을 하지 않아야 한다

## 주요 I/O 발생 지점 - 테이블 액세스 단계

- 인덱스 컬럼 추가  
- Batch I/O 활용 (batch_table_access_by_rowid 힌트 활용)  
- 클러스터링 팩터 개선  
- 클러스터링 전략: IOT, Cluster  
- Full Scan: 파티션, 병렬처리 활용

## 주요 I/O 발생 지점 - 인덱스 스캔 단계

- 인덱스 컬럼 순서 조정  
- Skip Scan 활용  
- 선분 조건 IN-List 변환  
- 선분 조건을 IN 서브쿼리, 조인으로 변환  
- 인덱스 컬럼 가공, 중간값 검색, 부정형 비교, OR 조건 / IN List, 옵션 조건에 대한 검토 및 튜닝

## 인덱스 설계

- 인덱스 선두컬럼을 조건절의 선두컬럼에 사용해야 함  
- 인덱스 선두컬럼이 = 조건이어야 스캔 효율이 좋음

## 스캔 효율성 외 판단 기준

- 쿼리 수행 빈도  
- 업무상 중요도  
- 클러스터링 팩터  
- 데이터량  
- DML 부하: 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신되는 컬럼 포함 여부  
- 저장 공간  
- 인덱스 관리 비용 등

## 인덱스 설계 어려움

- 개별 쿼리 성능, 인덱스 개수 최소화, DML 부하 줄임이라는 상충하는 목표를 조율

## 기타 설계 팁

- 스캔 범위가 넓지 않다면 범위조건 사용 무방  
- 자주 조회, DML 적고, 스캔 범위 넓지 않아도 = 조건 선두로  
- = 조건 컬럼은 인덱스 선두에 두어야 함  
- IN 조건 컬럼은 선두에 두지 않도록  
- 가급적 테이블 액세스 없이 인덱스에서 필터링 하도록 구성
