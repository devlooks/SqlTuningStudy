
# 비용 기반 옵티마이저 및 SQL 최적화 전략

## 비용 기반 옵티마이저 (CBO)
- 실행 계획 도출  
- 데이터 딕셔너리 → 통계정보 → 실행 계획 예상 비용 산정 → 비용 낮은 계획 선택  
- **통계 정보**: 데이터 양, 컬럼 값 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 등 고려  
- 규칙:
  - 비용 동일 시, 알파벳 순 선택
  - `FIRST_ROWS` 모드 → ORDER BY 컬럼 인덱스 우선 사용  
- 기본적으로 캐싱효과 고려 X → 모든 블록을 디스크에서 읽는다고 가정

## 규칙 기반 옵티마이저 (RBO)	
- 우선순위 규칙 기반 실행 계획 선택

## 옵티마이저 서브엔진
- **Query Transformer**: SQL 구조 최적화 유리하게 변환  
- **Estimator**: 선택도, 카디널리티, 비용 계산  
- **Plan Generator**: 후보 실행 계획 생성

## 힌트 (HINT)
- 명령어로 취급됨
- 무시되는 경우:
  - 문법 오류
  - 잘못된 참조
  - 논리/의미 오류
  - 내부 쿼리 변환
  - 버그

---

## 바인드 변수 관련

### Bind Variable Peeking (Parameter Sniffing)
- 바인드 변수 값 기반으로 실행 계획 결정
- 히스토그램 사용 제약 극복 목적

### Adaptive Cursor Sharing
- 바인드 변수 분포에 따라 실행 계획 변경

### Cardinality Feedback
- 예상 카디널리티와 실제 결과 차이 클 경우 → 새로운 실행 계획 생성

### Adaptive Plans
- 런타임 실행 계획 변경 가능

---

## 통계 정보

### 오브젝트 통계
- 테이블, 인덱스, 컬럼 통계 포함

### 시스템 통계
- CPU 속도
- Single Block I/O 속도
- Multi Block I/O 속도/갯수

### Adaptive Direct Path Read
- 버퍼 캐시 크기 등 고려하여 Direct Path Read 실행 여부 결정

---

## 환경에 따른 최적화

- **2-Tier**: SQL 커서 오픈 상태 유지 필요 → Fetch 중 멈춤 발생
- **3-Tier (OLTP)**: 페이징 처리 방식 효율적  
- 아키텍처에 따라 최적화 목표 달라짐

---

## 옵티마이저 영향 요소

- 인덱스, IOT, 클러스터링, 파티셔닝 등
- 제약 조건 (PK, FK, CHECK, NOT NULL)
- 통계 정보
- 옵티마이저 힌트
- 관련 파라미터

---

## 옵티마이저 한계

- 부족한 옵티마이저 팩터
- 부정확한 통계
- 결합 선택도 산정 어려움
- 바인드 변수 사용 → 히스토그램 활용 제약
- 비현실적 가정, 규칙 의존
- 최적화 시간 제한 존재

---

## 용어 정리

- **선택도**: 1 / NDV  
- **카디널리티**: 총 로우 수 / NDV

---

## 컬럼 통계 항목

- 중복 제거된 값 수
- 최소/최대 값
- 밀도
- 평균 컬럼 길이
- NULL 수

---

## 시스템 통계 항목

- CPU 속도
- Single Block I/O 평균 속도
- Multi Block I/O 평균 속도 및 개수
- I/O 서브 시스템 최대 처리량
- 병렬 slave 평균 처리량

---

## 비용 모델

- **I/O 비용 모델**: 디스크 I/O Call 횟수  
- **CPU 비용 모델**: 예상 I/O 및 CPU 시간  

---

## 히스토그램 유형

- 도수 분포: 값 별 빈도  
- 높이 균형: 버킷 높이 동일  
- 상위 도수 분포: 상위 N개 값 빈도  
- 하이브리드: 도수 + 높이 균형 결합  
- 넓이 균형은 미사용

---

## 인덱스 기반 테이블 액세스 비용

```text
브랜치 레벨 +
(리프 블록 수 × 유효 인덱스 선택도) +
(클러스터링 팩터 × 유효 테이블 선택도)
```

---

## 파싱 유형

- **소프트 파싱**: 실행 계획 캐시에서 조회  
- **하드 파싱**: 실행 계획 없을 때 새로 생성

---

## 공유 SQL 및 커서 관리

- 영구 저장 오브젝트: 함수, 프로시저, 패키지 등  
- SQL 문은 이름 대신 전체 텍스트로 구분  
- 캐시 부족 시 실행 계획 폐기 후 재사용

---

## SQL 최적화 필수 정보

- 테이블, 컬럼, 인덱스 구성 정보  
- 오브젝트 통계 (히스토그램 포함)  
- 시스템 통계  
- 옵티마이저 파라미터

---

## 조건절 및 히스토그램

- **상수값 사용**: 히스토그램 활용  
- **바인드 변수**: 히스토그램 미사용 → 부정확한 실행 계획 가능

---

## 커서 종류

- **Open Cursors**: 세션당 커서 수 제한  
- **명시적 커서**: DECLARE → OPEN, FETCH, CLOSE  
- **묵시적 커서**: 자동 처리  
- **공유 커서**: Shared SQL Area  
- **세션 커서**: PGA에 저장된 Private SQL Area  
- **애플리케이션 커서**: 클라이언트 핸들

---

## Static vs Dynamic SQL

- **Static SQL**: 코드 내 직접 기술 (PL/SQL 등)  
- **Dynamic SQL**: 문자열 변수 기반 (JDBC 등)

---

## CURSOR_SHARING

- `FORCE`: 상수 → 바인드 변수 변환  
  - 하드 파싱 줄임  
  - CPU 사용량 감소  
  - 히스토그램 미사용 → 비효율 가능

---

## 쿼리 변환

- **Heuristic 쿼리 변환**: 무조건 수행  
- **Cost-based 쿼리 변환**: 비용 기준으로 수행 여부 판단 (일반적)

---

## 서브쿼리 최적화

- 서브쿼리 블록 단위 최적화  
- 캐싱 효과: return 값 적을수록 효율↑  
- **Unnesting**:
  - 조인 순서 및 기준 변경
  - Semi Join 사용 (NL_SJ)
  - OUTER 테이블 조인 성공 시 진행 중단
- **Not Exists** → `UNNEST HASH_AJ`
- Unnest 불가 시 → 필터 방식 사용

---

## Unnest 관련 힌트

- `/*+ NO_UNNEST PUSH_SUBQ */`: 필터 방식 우선  
- `/*+ NO_MERGE PUSH_PRED */ + GROUP BY + 스칼라 쿼리`: 부분 처리 가능  
- 뷰 존재 시: `VIEW` 연산자 존재 → MERGE 여부 판단

---

## 실행계획 예시 구문 변경
```sql
-- 기존
, (SELECT LPAD(AVG(...), 10) || LPAD(MIN(...), 10) || MAX(...))
-- 변경
, TO_NUMBER(SUBSTR(..., 1, 10))
, TO_NUMBER(SUBSTR(..., 11, 20))
, TO_NUMBER(SUBSTR(..., 21))
```

---

## 조건절 이행 (Transitive)

- 동일 조건 oracle 자동 생성 처리
- A = B, B = C → A = C  
- A > B, B > C → A > C

---

## OR Expansion

- OR 조건 → UNION ALL  
- 힌트: `USE_CONCAT`, 방지: `NO_EXPAND`  
- 실행계획 연산자: `CONCATENATION`  
- `NVL`, `DECODE` 시 적용 옵션: `_or_expand_nvl_predicate=TRUE`

---

## 공통 표현식 제거

- 동일 조건은 한 번만 평가
