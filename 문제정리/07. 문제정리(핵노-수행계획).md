
# Oracle 아키텍처 및 SQL 처리 구조 정리

## 1. DB 인스턴스 정의

- **DataBase**: 물리적인 OS 파일의 집합
- **인스턴스 (Instance)**: SGA(공유 메모리) + 프로세스 집합
  - 인스턴스:데이터베이스 = 1:1
- **RAC 환경**: 여러 인스턴스가 하나의 DB를 접근 (1:M)

---

## 2. 오라클 백그라운드 프로세스

| 프로세스 | 설명 |
|----------|------|
| SMON (System Monitor) | 인스턴스 복구, 임시 세그먼트 정리, 익스텐트 모니터링 |
| PMON (Process Monitor) | 비정상 종료된 프로세스 리소스 정리 |
| DBWR (DB Writer) | Dirty 버퍼를 데이터파일에 기록 |
| LGWR (Log Writer) | Redo 로그 버퍼의 내용을 Redo 로그 파일로 기록 |
| CKPT (Checkpoint) | 체크포인트 시 변경사항 저장 |
| RECO | 분산 트랜잭션 복구 |

---

## 3. Redo & Undo 메커니즘

### Redo 로그 목적

1. **DataBase Recovery**: 물리적 장애 → Archived Redo Log 활용
2. **Cache Recovery (Instance Recovery)**: 비정상 종료 → Redo 로그 기반 복구
3. **Fast Commit**: Append 방식 → 빠른 커밋, 나중에 기록 보장

### Redo 메커니즘

- **Log Force at Commit**: 커밋 시점에 로그 기록
- **Fast Commit**: Redo 로그만 기록, 데이터파일은 나중에 기록
- **Write Ahead Logging**:
  - 변경 전 Redo 로그 기록
  - DBWR: Dirty 블록 → 데이터파일 기록
  - LGWR: Redo 엔트리 → Redo 로그파일 기록

### Undo 사용 목적

- 트랜잭션 롤백
- 트랜잭션 복구 (인스턴스 복구 시 Rollback)
- Read Consistency 유지

---

## 4. 데이터 저장 구조

| 구성 요소 | 설명 |
|------------|------|
| 블록 (Page) | I/O의 최소 단위, 전체 블록 읽음 |
| 익스텐트 | 연속된 블록 집합, 공간 확장 단위 |
| 세그먼트 | 익스텐트의 집합, 테이블/인덱스/파티션 등 오브젝트 단위 |
| 테이블스페이스 | 다수의 세그먼트와 데이터파일로 구성 |

---

## 5. 로그 스위치와 주의사항

- 자주 발생 → 백업 미완료 시 DB Hang 가능
- 적절한 Redo 로그 파일 개수 필요

---

## 6. SQL 처리 과정

1. **파싱**
   - 파싱트리 생성
   - 구문(Syntax) / 의미(Semantic) 분석
2. **최적화**
   - 실행계획 도출
   - 비용 기반 판단 (CBO)
3. **로우소스 생성**

---

## 7. 옵티마이저 (CBO)

- **비용 기반 옵티마이저**
  - I/O 발생량 등 예측하여 최소 비용 경로 선택
  - 단 하나의 실행계획 선택

### 옵티마이저 힌트 무시 조건

1. 문법 오류
2. 잘못된 테이블 참조
3. 논리적 불가능
4. 의미적 오류
5. 쿼리 변환으로 무시

> SQL Server는 힌트 오류 시 **에러 발생**

---

## 8. 힌트 작성 규칙

- 힌트 안에서는 `,` 사용 가능
- 힌트 간에는 `,` 사용 불가
- 테이블 스키마 명시 ❌
- Alias 지정 시 반드시 사용해야 함

---

## 9. SQL & 캐시 메커니즘

- **Sort Area**: PGA 내 생성
- **SQL**: 라이브러리 캐시에 저장
- **버퍼 블록 상태**:
  - Free
  - Dirty
  - Pinned
- **SQL 언어 특징**: 구조적, 집합 기반, 선언적

---

## 10. Oracle의 데이터 읽기 중 변경 케이스

1. CR Copy 블록 생성하여 과거 시점 읽기
2. Undo 정보 사용 (단, Undo 블록 재사용 시 문제)
3. CR Copy 생성 실패 시: `SnapShot Too Old` 에러 발생

---

## 11. I/O 및 캐시

### 블록 단위 I/O 발생 조건

- DB 버퍼 캐시에 블록 적재
- Direct Path I/O로 데이터 파일에서 직접 읽기
- 버퍼캐시의 블록을 읽고 쓰는 경우

### Row 단위 I/O

- Row Cache → 딕셔너리 캐시 (ex: 테이블 컬럼 정보)

### 버퍼 캐시 탐색 메커니즘

- Direct Path I/O 제외, 대부분 버퍼 캐시 경유
- 인덱스 루트 → 브랜치 → 리프 → 테이블 접근

### 병렬 + FullScan → Direct Path I/O 발생

---

## 12. 캐시 히트율 계산

```text
히트율 = (1 - disk / (query + current)) * 100
```

---

## 13. 캐시 알고리즘

- **LRU (Least Recently Used)**: 오래된 것부터 제거
- **MRU (Most Recently Used)**: 최근 사용 데이터 보존

---

## 14. I/O 유형별 특징

| I/O 유형 | 설명 |
|----------|------|
| Sequential I/O | 연속된 블록 차례로 접근 |
| Random I/O | 특정 블록만 불규칙 접근 |
| Single Block I/O | 인덱스 스캔 (`db file sequential read`) |
| Multi Block I/O | Full Scan 시 사용, 블록 여러 개 읽기 (`db file scattered read`) |

> Multi Block I/O: `db_file_multiblock_read_count` 제한, 익스텐트 경계는 넘지 않음

---

## 15. 병렬 쿼리 부작용

- CPU 및 메모리 사용량 증가
- LGWR 처리량 증가 → 커밋 지연 발생

---
