
# Oracle 고급 성능 및 아키텍처 정리

## Redo 로그의 3가지 목적

- **Data Recovery (Media Recovery)**  
- **Cache Recovery (Instance Recovery)**: Undo 사용하여 Rollback 수행
- **Fast Commit**: Redo 로그만으로 빠르게 커밋

---

## SQL 언어의 구조

- **구조적**, **집합 기반**, **선언적 질의 언어**

---

## 실행계획 관련 패키지

- `DBMS_XPLAN.DISPLAY`: 예상 실행계획(Explain for)
- `DBMS_XPLAN.DISPLAY_CURSOR`: 실제 실행 후 계획 + 트레이스 정보

---

## 인덱스 관련 사항

- 인덱스 구성 컬럼이 모두 NULL인 경우 저장 안함  
- 하나라도 NOT NULL이면 인덱스에 저장됨

### 클러스터링 팩터

- 클러스터링 팩터 ↑ → 테이블 액세스 시 읽는 블록 ↓  
- 손익 분기점 ↑ → 인덱스 효용성 ↑  
- 추출건수 ↑ → 인덱스 접근보다 테이블 스캔이 유리한 시점 발생

---

## ORDER BY + 등치 조건

- 인덱스 후행 컬럼에 대해 ORDER BY 가능  
- 소트 연산 생략 가능  
- 조건 만족하는 만큼의 I/O는 발생

---

## 인덱스 설계 기준

- 등치 조건을 선두 컬럼에 구성
- IN 조건 → IN-List → Index Range Scan 가능

---

## 조인 전략

### Nested Loop Join

- 후행 집합 인덱스 사용 필수
- 선행 집합은 Table Full Scan이 유리할 수 있음
- 랜덤 액세스 기반 → 대용량 조인시 불리

### Hash Join

- SGA 버퍼 캐시에서 읽고
- PGA에 해시맵 생성 → 래치 불필요
- 해시 영역 초과 시 → Temp 테이블 스페이스 사용

---

## 통계 수집

- DBA 주도
- 옵티마이저가 동적 수집할 수도 있으나 Dictionary 저장 X

---

## 커서 캐싱

- **Session 커서 캐싱**: `session_cached_cursors`로 제어
- **Application 커서 캐싱 (Java)**: Statement 반복 재사용
- SQL이 불필요하게 길 경우 → 라이브러리 캐시 효율 ↓

---

## 바인드 변수 사용 이점

1. 커서 공유 가능
2. 하드 파싱 1회로 끝
3. 상수 조건 반복 처리
4. SQL 사용자 다르면 별도 커서
5. 트레이스로 사용 유무 판단 불가

---

## USE_CONCAT 힌트

- OR, NVL, NOT BETWEEN → UNION ALL 변환 유도

---

## Direct Path Insert 성능 이유

- HWM 외 영역에 순차 입력 (Freelist 미사용)
- 버퍼 캐시 탐색 X
- 데이터 직접 기록
- Undo 로깅 최소화
- `NOLOGGING` → Redo 로깅 최소화
- 테이블 TM Lock (Exclusive)

---

## Array Size 효과

- Array Size ↑ → DB Call, Block I/O ↓
- Fetch Call 지연 발생 가능
- 단, `INSERT INTO SELECT`에는 영향 X

---

## DML → Fetch Call 발생하지 않음

---

## 세션 커서 캐싱 확인

- 트레이스로 확인 불가
- `v$open_cursor` → session_cursor 항목으로 확인 가능

---

## Parse / Execute Call 해석

- `Parse Call = 1, Execute Call = 500` → Application 커서 캐싱
- `Misses in library cache during parse = 1` → 하드 파싱
- `Parse Call = 1, Miss = 1` → Soft 파싱 O

---

## 병렬 조인 및 연산

- 해시 조인, ORDER BY, GROUP BY → 병렬도(DOP) × 2 + 1 프로세스 필요
- QC (Query Coordinator) 포함됨

---

## SELECT FOR UPDATE

- 변경 목적으로 레코드 조회
- 동시성 ↓, `WAIT`, `NOWAIT` 적극 활용
- `MAX + 1` 패턴 → 중복 가능성 있음 → 재시도 → 성능 저하
- TM Lock 사용

---

## 버퍼 상태 종류

- **Free**: 비어있는 버퍼
- **Dirty**: 디스크와 동기화 필요
- **Pinned**: 현재 사용 중

### Checkpoint

- 일정량 Dirty 버퍼 → 데이터 파일 기록
- 목적: 공간 확보 + 장애 복구 최소화

---

## SQL Server Join

- FROM절 나열 순서 = 조인 순서
- 조인 순서 강제: `FORCE ORDER`

---

## 카디널리티 계산

```
카디널리티 = (1 / NDV) * (1 / NDV) * 총로우수
```

---

## 격리 수준의 이상 현상

- **Dirty Read**: 비일관성 데이터
- **Non-Repeatable Read**: 읽은 값이 달라짐
- **Phantom Read**: 새로 생긴 로우 존재

---

