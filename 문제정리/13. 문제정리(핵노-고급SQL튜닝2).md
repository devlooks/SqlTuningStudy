
# 테이블 파티셔닝 및 병렬 처리 전략

## 테이블 파티셔닝 개요

- 성능 향상, 경합 분산
- 저장 공간 측면에서 효율성 낮음 (여유공간, 세그먼트 단위 관리)

### 파티션 기준

- 여러 컬럼 선택 가능
- 문자형 컬럼 선택 가능 → 에러 없음 → `MAXVALUE` 파티션 추가 권장

### 파티션 방식

- **List 파티션**: 단일 컬럼 기준
- **Range, List**: 사용자 지정 → 데이터 몰림 방지 필요
- **Hash**: DBMS 해시 알고리즘 → 자동 분할 → 데이터 몰림 없음

> List 파티션 + `BETWEEN` 조건 → Partition Pruning 가능

---

## Partition Pruning

- **정적 Pruning**
  - 파티션 키 + 상수 조건
  - 실행계획: `Pstart`, `Pstop` → 파티션 번호 명시

- **동적 Pruning**
  - 파티션 키 + 바인드 변수 조건
  - 실행 시점에 파티션 결정
  - 실행계획: `Pstart`, `Pstop`에 `KEY`
  - NL Join + 조인 조건 + 파티션 키 + `BETWEEN` 조건 → 작동

> 파티션 컬럼 가공 시 → Partition Pruning 불가능 (`Partition Range ALL`)
> `LIKE` 조건 → 불필요한 스캔 발생 → `BETWEEN` 조건 선호

- 정적 vs 동적 Pruning → 성능 차 거의 없음
- 숫자형과 문자형 비교 시 자동 형변환 발생

---

## 파티션 재구성 및 인덱스

- **비파티션/Global 파티션 인덱스** → `Unusable` 상태로 변경됨
- **Local 파티션 인덱스**
  - 자동 재구성 가능
  - 루트→리프 depth 낮음 → 인덱스 탐색 시 블록 적음
  - 관리 편의성 높음, 성능 양호
  - 테이블과 1:1 대응 관계는 아님

- **Local 인덱스**
  - 테이블 파티션 속성 상속
  - 파티션 구성 변경 → 인덱스 재생성 불필요

- **Global 인덱스**
  - 파티션 키가 다르거나 파티션 기준 다름
  - 변경 시 `Unusable` → 인덱스 재생성 필요 → 서비스 중단 우려
  - Global Non-Prefixed 인덱스는 실제 생성 거의 없음

- **Unique 인덱스 파티셔닝**
  - 파티션 키가 모든 인덱스 컬럼에 포함되어야 함

---

## 병렬 처리 기초

- 배치 프로그램 → OLTP, DW/OLAP 모두 활용
- 절차형, One SQL형 → 인덱스 구성 중요
- 병렬 프로세스는 일괄 종료 → 자원 해제 순으로 처리

### 병렬 처리 종류

- **Intra-Operation**: 배타적 범위 동시 처리  
- **Inter-Operation**: 서버 간 데이터 전달 (조인, 그룹핑 등)

---

## IN-OUT 오퍼레이션

- `PARALLEL_FROM_SERIAL (S→P)`  
- `PARALLEL_TO_SERIAL (P→S)`  
- `PARALLEL_TO_PARALLEL (P→P)` → Inter-Operation

- `PARALLEL_COMBINED_WITH_PARENT (PCWP)`  
- `PARALLEL_COMBINED_WITH_CHILD (PCWC)` → 통신 없음

---

## Broadcast

- 모든 병렬 프로세스에 데이터 전송 (두 번째 서버집합)
- 작은 테이블에 적합한 병렬 조인 방식

---

## Granule

- 병렬 처리 최소 단위  
- 병렬 서버는 1개 Granule 단위 처리

### 블록 기반 Granule
- 파티션 수 무관 → 병렬도 유연
- 처리량 편차 적음

### 파티션 기반 Granule
- 파티션 수 = 병렬 수
- Partition-Wise 조인, 인덱스 병렬 처리, 병렬 인덱스 생성
- 파티션 수보다 병렬도 크면 리소스 낭비
- 데이터 편차 클수록 비효율

| 작업 유형                | 권장 Granule                             |
| -------------------- | -------------------------------------- |
| Table Full Scan      | Block 기반                               |
| Index Fast Full Scan | Block 기반                               |
| Partition-Wise Join  | Partition 기반                           |
| 파티션별 갱신/생성           | Partition 기반                           |
| 데이터 정렬               | Block 기반 (또는 Partition 기반, 데이터 크기에 따라) |


---

## 병렬 처리 + 인덱스/테이블 스캔

- Index Range Scan + 병렬  
  - 파티션 Granule → 병렬도 제한

- Table Full Scan, Index Fast Full Scan  
  - 블록 Granule → 병렬도 자유롭지만 작은 테이블은 낭비

- 병렬 SQL → 부분 범위 처리, 소트 연산 생략 불가
  - Full Scan, Index Fast Full Scan 유리

- 병렬 중간에 `PARALLEL_TO_SERIAL` → 병목 발생 가능

---

## 병렬 조인 전략

- **Full Partition-Wise Join**
  - 양쪽 테이블 파티션 기준 동일하지 않아도 무방
  - 데이터 재분배 불필요
  - 병렬 프로세스 2배 필요 없음

- **Partial Partition-Wise Join**
  - 한쪽 기준에 따라 동적 파티셔닝 → 병렬 조인
  - 데이터 재분배 발생, 병렬 프로세스 2배 필요
  - 예시:
    - 1000만 + 1억 → Hash 분배 유리
    - 10만 + 5억 → Broadcast 유리

- 옵티마이저 + Index Scan → `PARALLEL` 힌트 무시됨
  - `PARALLEL + FULL`, `PARALLEL + INDEX_FFS` 같이 사용 권장

---

## 병렬 힌트 및 제약

- Broadcast 사용 시 → 작은 데이터 → Parallel 힌트 불필요
- 큰 두 테이블 → 파티셔닝 없거나 기준 다름 → Temp 사용 증가
- 조인 전략: NL, Sort Merge, Hash 가능
- `PARTITION WISE JOIN` 실행계획: `Hash Join + PX Partition Range All`
- Full Partition-Wise Join → 하나의 서버 집합만 필요
- 파티션 인덱스 → 병렬도 설정 가능 (단, Granule 제한 존재)

---

## 병렬 DML 및 힌트

- 병렬 DML → Exclusive Lock 발생 → 주간 사용 지양
- 힌트:
  - `PARALLEL` + `FULL`
  - `PARALLEL_INDEX`, `INDEX`, `INDEX_FFS`

- 병렬 조회 이후 → 작은 쿼리 처리 전 커서 닫기 필수

---

## WITH 구문 처리 방식

- **Materialize**
  - 임시 테이블 생성 → SQL 수행 중 유지
  - Global Temp Table → Temp Tablespace에 기록
  - 읽을 땐 버퍼 캐시 경유
  - 원본 집합과 결과 차이 크지 않으면 효과↓  
  - 중간 집합 생성 시 Disk I/O 발생

- **Inline**
  - 임시 테이블 미생성 → 참조 횟수만큼 SQL 재수행
  - SQL Server는 Inline만 제공

> 실행계획: `VIEW` X → `NO_MERGE`  
> 실행계획: `VIEW` O → `MERGE()`

