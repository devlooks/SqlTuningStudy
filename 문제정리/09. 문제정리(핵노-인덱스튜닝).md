
# 인덱스 튜닝

## B*Tree 인덱스 구조
- **브랜치 블록**
  - 하위 블록에 대한 주소 값을 가짐
  - 각 로우의 키값은 하위 블록 값의 범위
- **리프 블록**
  - 각 로우는 테이블 로우에 대한 주소값
  - 각 로우 키값과 테이블 로우의 키값은 서로 일치
  - 각 로우 키와 테이블 로우 간 1:1 관계
  - 리프 블록 끼리 이중연결 리스트

## 인덱스 ROWID
- 오라클 초기 ROWID: 데이터 파일 번호 + 블록 번호 + 블록 내 로우번호
- 확장 ROWID: 오브젝트 번호 + 데이터 파일 번호 + 블록 번호 + 블록 내 로우번호
- 테이블 스페이스는 인덱스 ROWID 요소가 아님

## 인덱스 탐색
- **B*Tree Index**
  - 루트 ⇒ 리프(수직 탐색 - 스캔 시작점 찾기) ⇒ 리프(수평 탐색)

## SQL Server WITH 절 INDEX 힌트
- 예시
  - `from 고객 WITH (Forceseek (고객_PK(고객번호)))` ⇒ Index Scan
  - `from 고객 WITH (Forcescan)` ⇒ Full Scan
  - `WITH (Index(1))` ⇒ 클러스터 ⇒ 인덱스 X ⇒ 구문 오류
  - `WITH (Index(0))` ⇒ 클러스터형 인덱스 Scan ⇒ 인덱스 X ⇒ 테이블 Full Scan

## WHERE 절 인덱스
- 선두 컬럼만으로도 인덱스 스캔 가능 (등치 조건은 필수 아님)

## Index Full Scan
- 리프 블록 전체 스캔
- 인덱스 선두컬럼 조건절 X
- 조건절 없이 선두컬럼 존재
- 컬럼이 작은 인덱스일수록 유리 (조건 만족 데이터 적은 경우)
- 부분처리 효과적
- 오라클은 지원X ⇒ 조건절에 인덱스 선두컬럼 없도록 유도 필요

## PK 인덱스
- Unique 인덱스
  - 등치조건 + Unique 컬럼 → Index Unique Scan
  - 일부 조건만 → Range Scan

## 인덱스 리프블록
- 여러 익스텐트에 분산 저장
- 정렬 순서 + 이중 연결 리스트로 결과 순서 보장

## Index Fast Full Scan
- 논리적 연결 순서 없음
- HWM 아래 익스텐트 전체 MultiBlock I/O 방식
- 결과 집합 순서 보장하지 않음

## Index Skip Scan
- NDV 낮은 인덱스 선두컬럼 조건절 없을 때 유용
- 선두 O + 중간 X + 후행 O ⇒ Skip Scan 가능
- IN 조건 + 인덱스 엑세스 조건 ⇒ Skip Scan

## B*Tree 인덱스 단점: Fragmentation
- Index Skew: 엔트리 치우침
- Index Sparse: 밀도 낮음
- 모든 리프블록까지의 높이 동일

## 비트맵 인덱스
- 대용량, 다중 인덱스 컬럼에 유용
- Distinct Value 적을수록 효율↑
- Bitwise 연산으로 DW/OLAP 적합
- DML, Lock 관련 부하 큼

## 함수기반 인덱스
- 인덱스 컬럼에 함수 적용 가능

## 리버스키 인덱스
- 다중 트랜잭션 경합 해결 목적
- 생성: `CREATE INDEX ON TableName (REVERSE(col))`
- 사용:
```sql
SELECT *
FROM t A
WHERE REVERSE(col) = REVERSE(:keyword)
```

## IOT (Index Organized Table)
- 테이블을 인덱스 구조로 관리
- PK 기준 정렬

## 클러스터
- 동일 값 레코드를 같은 블록에 저장
- 랜덤 액세스 감소

## 테이블 파티션
- 세그먼트 단위로 저장
- Full Scan 빠름
- 오라클: IOT → PK 기준
- SQL Server: 클러스터 인덱스는 일반 컬럼 정렬 기준, 한 개만 가능

## Index Range Scan 불가 케이스
- 인덱스 컬럼 가공
- `LIKE '%~%'` (중간값 검색)
- 부정형, 형변환, OR 조건 (UNION ALL + USE_CONCAT 가능)

## IS NULL 조건 Index Range Scan
- 구성 컬럼 모두 NULL → 저장 X → Scan X
- 일부 NOT NULL → Scan 가능

---

## 테이블 액세스 최소화

- **ROWID**: 데이터파일번호 + 블록번호 → 캐시 찾음 → 없으면 DISK I/O
- 블록 주소 + 해시함수 → 해시 체인 → 버퍼 헤더

## 버퍼 캐시 접근
- Latch(경합), Buffer, Lock 필요

## 클러스터링 팩터
- 인덱스 컬럼 순으로 테이블 재정렬 → 향상
- 좋으면 블록 I/O 감소
- 나쁘면 손익분기점 낮음

## MultiBlock I/O
- 블록 단위 ↑ → 디스크 I/O 횟수 ↓ → 손익분기점 낮음

## 비용 비교
- **테이블 스캔**: 데이터 양 ↑ ⇒ 선형 증가
- **인덱스 스캔**: 추출 건수 ↑ ⇒ 기하급수 증가
  - 클러스터링 팩터 ↓, 버퍼캐시 히트율 ↓
  - 데이터 양 ↑ ⇒ 테이블 스캔 비용적 유리

## 온라인 프로그램 튜닝
- 조인: NL JOIN
- 소트 연산 제거
- 부분 처리 방식

## 배치 프로그램 튜닝
- 전체 범위 데이터
- Full Scan, Hash Join 유리

## 인덱스 추가 고려
- 액세스 많고 결과 적음
- 필터 조건을 인덱스화

## 랜덤 액세스 많을 때
- 컬럼 추가 우선 고려

## IOT
- 랜덤 액세스 적을수록 효과적

## 인덱스 재구성
- 스캔 비효율 감소
- 엑세스 적으면 효과↓  

## 인덱스 정렬 테이블 액세스
- 클러스터링 팩터 향상 → 랜덤 액세스 감소

## 인덱스 컬럼 추가
- 사이즈 증가
- 선두 컬럼 NDV ↓ → 클러스터링 팩터 좋음

## 배치 I/O
- Disk I/O Call 모아 처리
- 정렬 순서 상이 가능
- 실행계획 `Batched` 키워드
- `ORDER BY` 시 정렬 가능, 부분처리 X

## 인덱스 튜닝 핵심 요소
- 인덱스 스캔 비효율 (스캔양 대비 결과 적음)
- 테이블 액세스 비효율 (엑세스 대비 결과 적음)

## 인덱스 스캔 효율
- 선행 컬럼 조건 X (부등호, 범위) → 후행 컬럼은 FILTER 처리 → 비효율

## 기타
- **Index Fast Full Scan**: 인덱스 포함 컬럼만 조회 시
- **Index Skip Scan**: 선두 NDV ↓, 후행 NDV ↑ 시 유리
- **IN 조건 + 인덱스 컬럼**: 수직 탐색 횟수 ↑ → 비효율
