# 인덱스 튜닝

B*Tree 인덱스 구조
  - 브랜치 블록
      - 하위 블록에 대한 주소 값을 가짐
      - 각 로우의 키값은 하위 블록 값의 범위
  - 리프 블록
      - 각 로우는 테이블 로우에 대한 주소값
      - 각 로우 키값과 테이블 로우의 키값은 서로 일치한다.
      - 각 로우 키와 테이블 로우간 1:1 관계
      - 리프블록 끼리 이중연결 리스트
   
인덱스 ROWID
  - 오라클 초기 ROWID => 데이터 파일 번호 + 블록 번호 + 블록내 로우번호
  - 확장 ROWID => 오브젝트 번호 + 데이터 파일 번호 + 블로 ㄱ번호 + 블록내 로우번호
  - 테이블 스페이스는 인덱스ROWID 요소가 아님

인덱스 탘색
  - B*Tree Index
    - 루트 => 리프(수직 탐색 - 스캔 시작점 찾기) => 리프 (수평 탐색)
   
SQL Server WITH 절 INDEX 힌트  
  - ex) from 고객 WITH (Forceseek (고객_PK(고객번호))) => index Scan  
  - ex) from 고객
          - WITH (Forcescan) => Full Scan  
          - WITH (Index(1)) => 클러스터 => 인덱스 X => 구문 오류
          - WITH (Index(0)) => 클라스터형 인덱스 Scan => 인덱스X => 테이블 Full Scan

WHERE 절 인덱스 선두 컬럼 => 인덱스 스캔 => 단, 등치 조건일 필요는 없음.

Index Full Scan
  - 리프블록(Index) 처음부터 끝까지 모두 스캔
  - 인덱스 선두컬럼 X
  - 인덱스 선투 컬럼, 조건절X
  - 컬럼이 작은 인덱스 선택시 I/O 발생이 적음( 조건 만족 데이터가 적은 경우)
  - 부분처리에서 활용시 효과적
  - 오라클 지원X => 유도방법 조건절에 인덱스 선두컬럼X 경우

PK 인덱스는 Unique
  - 전체 데이터 -> Unique 인덱스 구성컬럼 + 등치조건 => Index Unique Scan
  - 일부 데이터 -> .. => Range Scan 선택

인덱스 리프블록 
  - 물리적으로 여러 익스텐트에 흩어진 상태, 저장
  - 정렬 순서대로, 이중 연결리스트 => 결과집합 순서 보장

Index Fast Full Scan
  - 논리적 연결순서X
  - HWM 아래 익스 텐트 전체 MultiBlock I/O 방식
  - Full Scan 이므로 결과 집합의 순서 보장 하지 않음

Index Skip Scan
  - NDV 가 적은 인덱스 선두컬럼이 조건절에 없을때 유용
  - NDV가 적은 두개의 선두컬럼이 모두 조건절이 아님
  - 선두조건 O + 중간컬럼 X + 후행 컬럼 O
  - IN 조건 + 인덱스 엑세스 조건 => Skip Scan

B*Tree 인덱스 - 단점 Index Fragmentation
  - Index Skew 인덱스 엔트리, 왼쪽, 오른쪽에 치우치는 현상
  - Index Sparse 인덱스 밀도가 낮은 현상

B*Tree 인덱스 => 모든 리프블록까지의 높이가 항상 동일

비트맵 인덱스
  - 인덱스 여러개 대용량 테이블에 유용
  - Distinct value 개수 적을수록 효율이 높음
  - Bitwise 연산 => DW/OLAP 환경 적합
  - 단점 : LOCK 에 대한, DML 부하 심함

함수기반 인덱스
  - 인덱스 컬럼에 함수적용

리버스키 인덱스
  - 다중 트랜잭션 -> 한쪽으로 몰릴떄 Reverse Key Index => 경합 해수
  - 생성 : create index on TableName (Reverse(col));
  - 사용 ex)
    ```
    select *
    from t A
    where Reverse(col) = Reverse(:keyword)
    ```

IOT 
  - 테이블을 통째로 인덱스 구조로 관리
  - 키값(PK) 순 정렬

클러스터 
  - 레코드를 한블록에 모아 저장(같은 값끼리, 데이터 많을 수록 여러블록)
  - 테이블 랜덤 액세스 줄임

테이블 파티션
  - 데이터를 세그먼트 단위로 모아 저장(사용자 지정 기준)
  - Full Scan => 빠르게 탐색

오라클 => IOT => PK 컬럼 기준

SQL Server => 클러스터인덱스 => 일반 칼럼 => 정렬기준 => 한개만 생성 가능

Index Range Scan 불가한 케이스
  - 인덱스 컬럼 가공
  - Like '% ~ %' 중간값 검색
  - 부정형
  - 형변환
  - OR 조건 (Union all로 분기시 가능 use_concat)

IS NULL 조건 Index Range Scan
  - 오라클 구성 컬럼 모두 NULL => 인덱스 저장X => Range Scan X
  - 오라클 구성 컬럼중 Not NULL 하나라도 존재 => Range Scan O

## 테이블 액세스 최소화

ROWID => 데이터 파일 번호 + 블록 => 바탕으로 클록의 캐시 찾음 => 없으면 DISK I/O
      => (블록 주소 + 해시함수) => 해시 체인 => 버퍼 헤더 찾음

버퍼캐시의 블록 읽을떄 => Latch(경합), Buffer, Lock 획득 필요

클러스터링 팩터 향상 => 인덱스 컬럼 순으로 정렬되도록 테이블 재생성

클러스터링 팩터 좋으면 블록 I/O 감소
클러스터링 팩터 나쁘면 손익분기점 내려간다

MultiBlock I/O 의 블록 단위가 높다 -> 디스크 I/O 횟수가 낮음 -> 손익분기점 낮음

테이블 스캔 비용 
  - 데이터 양 높을수록 => 선형적 증가

인덱스 테이블 스캔 비용 
  - 데이터양 높을수록 추출 건수 높음 => 기하급수적으로 증가
  - 데이터양이 높을수록 => 클러스터링 팩터 나빠짐
  - 버퍼 캐시 히트율은 낮아짐
-> 결론 -> 데이터 양이 높을 수록 테이블 스캔이 비용적으로 유리

온라인 프로그램 튜닝
  - 조인 => NL
  - 소트연산 생략
  - 부분 처리 방식

Batch 프로그램 튜닝
  - 데이터 전체 범위
  - Full Scan, 해시조인이 유리

테이블 액세스 많고 결과집합이 적다 -> 필터된 데이터 많다 -> 필터조건을 인덱스 추가로 해결

테이블 랜덤 엑세스 많음 => 컬럼 추가 우선 검토

IOT => 랜덤 엑세스 늦을 수록 가장 효과적
인덱스 재구성 => 인덱스 스캔 비효율을 줄이는데 도움됨 => 엑세스가 낮으면 도윰이 안됨
인덱스순 정렬 테이블 엑세스 => 클러스터링 팩터를 높임 => 랜덤 액세스 줄일수 있음

인덱스 컬럼 추가 => 인덱스 사이즈 증가
선두 컬럼 NDV 가 적다 => 클러스터링 팩터가 좋은 상태

배치 I/O
  - Disk I/O Call을 미뤘다가 한번에 처리
  - 정렬 순서 다를 수 있음
  - 실행계획 Batched 키워드
  - 부분 범위처리 가능 (order by 시 정렬 가능 단, 부분처리 안됨)

인덱스 튜닝 두가지 핵심 요소
  - 인덱스 스캔과정의 비효율 (스캔한 양에 비해 결과건수가 적음)
  - 테이블 액세스 횟수의 비효율 (엑세스 양에 비해 결과 건수가 낮음)

인덱스 스캔 효율
  - 선행 컬럼이 조건절이 X(부등호, 범위) => 후행 컬럼 모두 filter 조건 됨 => 비효율 발생

Index Fast Full Scan : 인덱스에 포함한 컬럼만 조회

Index Skip Scan : 인덱스 선두 컬럼 NDB가 낮은경우, 후행컬럼 NDV 면에 유리

인덱스 컬럼 + IN 조건일때 수직 탐색 횟수가 높아짐 => 비효율 발생함
