
# SQL 수행구조

## 데이터베이스 아키텍처

### DB 인스턴스 정의

- **DataBase**: 물리적인 OS 파일의 집합 (오라클)  
- **인스턴스**: SGA 공유 메모리 영역 + 엑세스하는 프로세스 집합 (1 인스턴스 : 1 database)  
- **RAC 환경**: 여러 인스턴스가 하나의 database에 접근 (1:M)

### 오라클 백그라운드 프로세스

- **System Monitor (SMON)**: 장애 시스템 재기동 ⇒ 인스턴스 복구, 임시 세그먼트, 익스텐트 모니터링  
- **Process Monitor (PMON)**: 이상이 생긴 프로세스가 사용한 리소스 복구  
- **DB Writer**: Dirty 버퍼를 Data file에 기록  
- **Log Writer**: 로그 버퍼 엔트리를 Redo 로그 파일에 기록  
- **CKPT**: CHECK POINT (변경사항 SAVING)  
- **Recoverer (RECO)**: 분산 트랜잭션 문제 해결

- 로그버퍼에 로그 기록 ⇒ 프로세스  
- 테이블 블록 변경 ⇒ log Writer (주기적 Redo 로그 파일 기록)

### 데이터 저장 구조

- **블록(=페이지)**: 대부분 DBMS는 블록 단위로 I/O 수행  
  - 레코드 조회 시, 해당 레코드가 속한 블록 전체 읽음  
- **익스텐트**: 공간 확장 단위, 익스텐트 크기만큼 연속된 블록 할당  
- **세그먼트**: 익스텐트의 집합 (인접하지 않을 수 있음)  
  - 오브젝트가 저장 공간을 사용할 때 세그먼트 단위 사용 (테이블, 인덱스, 파티션 등)  
- **테이블 스페이스**: 다수의 세그먼트 (데이터 파일)로 구성

### 오라클 Undo 사용 목적

- Transaction RollBack  
- Transaction Recovery (⇒ Instance Recovery 시, RollBack)  
- Read Consistency

### Redo 로그 3가지 목적

- **Database Recovery**: Media(물리적) Fail ⇒ Archived Redo 로그 이용  
- **Cache Recovery (Instance Recovery)**: 인스턴스 비정상 종료 ⇒ 데이터 유실 대비  
- **Fast Commit**: Append 방식 사용, 빠르게 로그파일 기록 ⇒ 이를 믿고 Commit 수행

### 로그 스위치

- 자주 발생 ⇒ 백업 미완료 상태에서 Online Redo 로그 스위칭 ⇒ DB Hang 발생  
- 적절한 개수의 Redo 파일 필요

### Redo 메커니즘

- **Log force at commit**: 커밋 시점에 로그를 데이터파일에 기록  
- **Fast Commit**: 디스크에 영구 기록 안 된 상태 ⇒ Redo 로그만으로 커밋 처리  
- **Write Ahead Logging**:  
  - 버퍼 갱신 전 Redo 엔트리를 로그 버퍼에 기록  
  - DBWR이 Dirty 블록을 데이터파일에 기록  
  - LGWR이 Redo 엔트리를 Redo 로그 파일에 기록

### 오라클 데이터 읽기 중 변경되는 케이스

1. 과거 시점의 CR Copy 블록 생성하여 읽음  
2. Undo 정보 이용 (단, Undo 블록이 다른 트랜잭션에 의해 재사용 가능)  
3. CR Copy 생성 불가 ⇒ Snapshot Too Old 에러 발생

### 기타

- **Sort Area** ⇒ PGA에 생성  
- SQL은 **라이브러리 캐시**에 캐싱  
- 버퍼 블록 상태: `Free`, `Dirty`, `Pinned`

## SQL 처리 과정

### SQL 언어의 특징

- 구조적, 집합 기반, 선언형

### SQL 처리 단계

1. **파싱**
   - 파싱 트리 생성
   - 구문(Syntax) 분석
   - 의미(Semantic) 분석
2. **최적화**
   - 실행계획 도출
   - 실행계획별 예상 비용 산정
   - 최저 비용의 실행계획 선택
3. **로우소스 생성**

### 비용 기반 옵티마이저 (CBO)

- 예상 비용 산정 후, 최저 비용 나타내는 실행계획 하나 선택  
- I/O 발생량 고려  
- 최종 목적은 **예상 비용 최소화**

### 옵티마이저 힌트 미적용 사유

1. 문법적으로 틀림  
2. 잘못된 참조  
3. 논리적으로 불가능  
4. 의미적으로 무효  
5. 쿼리 변환으로 인해 무시됨

> **SQL Server**는 힌트가 잘못될 경우 **에러 발생**

### 힌트 작성 규칙

- 힌트 안에서는 `,` 사용 가능  
- 힌트 사이에 `,` 사용 불가  
- 테이블 지정 시 스키마 명시 생략 가능  
- Alias 사용 시 반드시 Alias 사용

## 데이터베이스 I/O 메커니즘

### 블록 단위 I/O 발생 케이스

- Datafile에서 DB 버퍼로 블록 적재  
- Datafile에서 블록을 적재 (직접 접근 - Direct Path I/O)  
- 버퍼 캐시에서 블록 읽기 및 쓰기  
- 버퍼 캐시의 변경된 블록을 Datafile에 쓰는 경우

### 로우 단위 I/O (Row Cache)

- 딕셔너리 캐시 적재 (예: 테이블 컬럼 정보 등)

### 버퍼 캐시 탐색 메커니즘

- Direct Path I/O 제외, 대부분의 블록 I/O는 버퍼 캐시 통해 발생  
- 인덱스 루트 블록 ⇒ 브랜치 ⇒ 리프 ⇒ 테이블 액세스 ⇒ Full Scan

> **병렬 처리 + Full Scan** ⇒ Direct Path I/O 발생

### 버퍼 캐시 히트율

- `((query + current) - disk) / (query + current) * 100`  
- `(1 - disk / (query + current)) * 100`

### LRU / MRU

- **LRU (Least Recently Used)**: 마지막으로 사용된 데이터  
- **MRU (Most Recently Used)**: 가장 최근에 사용된 데이터

### I/O 유형

- **Sequential I/O**: 차례대로 블록 읽는 방식  
- **Random I/O**: 하나씩 접근하는 방식

### I/O 세부 유형

- **Single Block I/O (Index Scan)**  
  - 인덱스 루트 ⇒ 브랜치 ⇒ 리프 ⇒ 테이블  
  - `db file sequential read` 발생

- **Multi Block I/O (Full Scan)**  
  - 인접한 블록을 미리 읽어 캐시에 적재  
  - `db_file_multiblock_read_count` 설정  
  - 익스텐트 경계 넘지 않음  
  - 작은 익스텐트 사용 시 I/O 횟수 증가  
  - `db file scattered read` 발생

### 병렬 쿼리 자주 수행 시 발생 현상

- CPU 및 메모리 자원 과다 사용  
- LGWR 로 인해 커밋 성능 지연 현상 발생
