
# 소트 튜닝 및 SQL 처리 최적화

## 소트 수행 원리

- 정렬 대상 → SGA 버퍼 캐시에서 읽음  
- Sort Area(PGA)에서 정렬 시도  
- 정렬 양이 많을 경우 Temp 테이블 스페이스 임시 세그먼트에 저장  
- Sort Area가 찰 때마다 Temp로 저장 → Sort Runs  
- Temp에서 다시 읽을 때 Direct Path I/O 발생  
  - `direct path write temp`, `direct path read temp` 이벤트 발생

### 소트 유형
- **Optimal Sort**: Sort Area 내 작업 마무리  
- **One Pass Sort**: 디스크에 한 번 기록  
- **Multi Pass Sort**: 디스크에 여러 번 기록

### 정렬 관련 연산
- **Sort Group By**: Group By 시 → 결과 집합만큼 Sort Area 사용  
- **Sort Unique**: DISTINCT, UNIQUE 연산  
- **Sort Aggregate**: 집계 함수  
- **Sort Order By**: 전체 정렬 (인덱스로 생략 가능)  
- **Hash Group By**: Hash 알고리즘 사용

- **Sort Unique/Union All**: Union 집합 연산자 사용 시 발생 (중복 제거 시 인덱스 소트 생략 불가)  
- 소트 생략 = 부분 범위 처리 가능 = 인덱스 구성 필요

### 인라인 뷰 관련
- 인라인 뷰 안쪽 `ORDER BY` + 바깥쪽 `ROWNUM` → Top-N Stop Key  
- 인라인 뷰 결과집합이 크고 소트 발생 시 → 인라인뷰 바깥에서 조인 처리  

### 인덱스를 통한 정렬 생략 요건
- 조건절 컬럼과 `MIN`/`MAX` 인자 컬럼이 모두 인덱스에 포함  
- 등치 조건 사용한 조건절 컬럼  
- `ORDER BY` 컬럼 포함  
- 등치 연산자 아닌 컬럼은 데이터 분포 고려 후 추가

> IN 조건은 등치 조건 아님 → IN-List로 풀어야 적용 가능  
> (예: `SELECT ... UNION ALL SELECT ...`)

---

## DML 성능 관련 요소

- 인덱스, 무결성 제약조건, 조건절, 서브쿼리  
- Redo 로깅, Undo 로깅, Lock, Commit 등  
- DML 문은 항상 `ALL_ROWS` 모드로 수행 → 부분 처리 불가능  
- 커밋 자주 수행 시 성능 저하  
- 커밋 시 데이터파일에 즉시 기록 X → DBWR가 나중에 기록  

### Direct Path Insert
- `NOLOGGING` 옵션 → Insert에만 유효  
- `Execute TM Lock` 사용 → 테이블 DML 차단  
- Redo 로그 생성과는 별개 (직접적 관련 없음)  

### Array Processing
- `INSERT INTO SELECT` 문은 느릴 수 있음  
- `DELETE` → 레코드 단위, Redo/Undo 생성 → 느림  
- `TRUNCATE` → 익스텐트 반환 → 빠름  
- 성능 향상 위해:
  - 제약 조건 해제
  - 인덱스 `UNUSABLE` 처리  
  - `CTAS` → Direct Path Insert 수행됨  

---

## DB Call, Cursor, 캐싱

- 애플리케이션 캐싱 X → 바인드 변수 있어도 `Parse Call` 반복 발생  
- `Parse Call` → 하드 파싱 + 딕셔너리 조회 + `Recursive Call`  
- DB 저장형 프로시저 실행 시 → 내부 SQL 수행으로 `Recursive Call` 발생  
- 사용자 호출(User Call) → 네트워크 경유 → 부하 큼  
- 바인드 변수 사용해도 `DB Call` 자체 줄어들지 않음  

### Array Processing
- `Array Size` 증가 + 페이징 처리 → `Fetch Call` 감소  
- `Execute Call` 줄어듦 → `DB Call` 줄어듦  
- 전체 과정을 Array 단위로 구성 시 효과 극대화  
- `SDU`, `TDU`, 세션/패킷 크기 등은 `Fetch Call`에 영향 없음  

### 부분 범위 처리
- `Fetch Call`마다 일정량 전송  
- 모든 DBMS에서 사용 가능

---

## Full Table Scan & 함수 실행

- `MultiBlock I/O` 작게 → I/O 횟수 많음  
- `MultiBlock I/O` 크게 → I/O 횟수 줄어듦  
- 작은 익스텐트 구성 테이블은 I/O 증가  

### 함수 내장 SQL
- 함수 실행 횟수만큼 `Recursive Call` 발생  
- `PL/SQL` 내장 SQL → 자동 커서 캐싱  
- `Parse Call` 1회  
- 실행 횟수: `200 + 1(Parse Call)`  
- 확인: `Call Statistics`, `V$SQL` → `SQL_ID`  

---

## 함수 캐싱과 튜닝 전략

- **DB 저장 함수** → User Call → 성능 저하  
  - `CASE`문 전환 → `Recursive Call` 줄어듦  
  - `DETERMINISTIC` 함수 → 캐싱 효과  
  - 참조 테이블 변경 시 성능 저하 → Result Cache 효과↓  

- **호출 부하 줄이기 위한 전략**
  - 부분 처리  
  - 페이징 처리  
  - 스칼라 서브쿼리 캐싱  
  - 함수 → 조인문 변환

- **스칼라 서브쿼리 + 함수 조합** → 일관성 확보 X  
- `DETERMINISTIC` 함수: `Fetch Call` 단위로 캐싱 (PGA)  
- `RESULT_CACHE`: SGA에 캐싱 (일관성 확보)

---

## Native Compile
- 인터프리팅 부하 ↓  
- `Context Switching`, `Recursive Call` 부하 해소는 아님

---

## 조건절 내 함수 호출
- 필터 조건 → 실행 횟수만큼 함수 호출  
- 인덱스 엑세스 조건 → 호출 횟수 최소화
