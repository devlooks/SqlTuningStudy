
# Lock 경합 최소화 및 트랜잭션 처리 전략

## Lock 기본 개념

- Lock은 DML 수행 중 자연스러운 현상
- Lock 점유 시간이 길면 경합 발생 → 튜닝 필요
- 교착 상태(Deadlock) → DBMS 에러 발생 → 시스템 해소
- `SELECT FOR UPDATE`: 나중에 변경할 목적으로 Lock

---

## Lock Escalation

- **Lock 확장**: 페이지 → 익스텐트 → 테이블 레벨  
- **낮은 레벨 Lock**: 동시성↑, 메모리 사용↑ (Lock 수 많음)  
- **높은 레벨 Lock**: 동시성↓, 메모리 사용↓ (Lock 수 적음)  
- 오라클은 로우 속성에서 Lock 관리 → Escalation 없음

> 모든 DBMS → DML 시 배타적 Lock 사용 → 서로 블로킹

---

## Lock 호환성

- 다른 컬럼 UPDATE → Row 단위 Lock → Lock 경합 발생 가능
- **SQL Server**
  - SELECT → 공유락 → 공유락끼리는 호환 가능
  - 공유락과 배타락은 호환 불가
- **Oracle (MVCC)**
  - SELECT 문 → Lock 없음
  - 변경 중 데이터도 Lock 없음
  - `SELECT FOR UPDATE`, `UPDATE`, `DELETE`는 서로 블로킹

---

## 트랜잭션 처리

- SQL Server: DML 전 `BEGIN TRANSACTION` 필요 (기본 Auto Commit)
- 매번 명시하지 않기 위해 `SET IMPLICIT_TRANSACTIONS ON`
- **MVCC**: 변경 중 레코드 대기 X → Undo에서 변경 전 데이터 읽음

> SQL Server: 조회 중 레코드 변경 시 → 다음 레코드 이동 전까지 대기

---

## Unique 인덱스와 Insert 경합

- Unique 인덱스/제약 없는 Insert → 서로 블로킹 X
- Unique 제약 있는 경우 → 동일값 Insert 불가
- Insert 중 → 다른 Insert/SELECT/UPDATE/DELETE 불가

> Oracle: `SELECT`와 `INSERT` 상호 간섭 없음 (MVCC 모델)

---

## 바인드 변수와 Lock

- 동일 값 입력 시 → `SELECT FOR UPDATE` 간에도 블로킹 발생

---

## 오라클 Lock 구조

- **로우락, 테이블락** → DML 시 항상 획득  
- 테이블 Lock → 데이터 변경 완전 불가 X (Lock 모드에 따라 다름)
  - 예: `RX` 모드 TM Lock → 호환 가능
- **Lock 종류**
  - `TX Lock`: 트랜잭션별 1개
  - `TM Lock`: DML 수행 테이블별 1개

---

## 트랜잭션 ACID 특성

- **A (Atomicity)**: 원자성, 전부 성공/실패
- **C (Consistency)**: 일관된 상태 유지
- **I (Isolation)**: 중간 결과 접근 차단
- **D (Durability)**: 결과 영속 저장

---

## 동시 트랜잭션 이상 현상

- **Dirty Read**: 커밋되지 않은 데이터 읽음
- **Non-Repeatable Read**: 두 번 읽기 → 값이 달라짐
- **Phantom Read**: 두 번 범위 조회 → 새로운 행 생성

---

## 격리성 수준 비교

| 수준               | Dirty Read | Non-Repeatable | Phantom |
|--------------------|------------|----------------|---------|
| Read Uncommitted   | O          | O              | O       |
| Read Committed     | X          | O              | O       |
| Repeatable Read    | X          | X              | O       |
| Serializable       | X          | X              | X       |

- **Read Committed**: 읽기 전 공유 Lock → 다음 이동 시 Lock 해제
- **Repeatable Read**: 트랜잭션 종료 시까지 Lock 유지
- **Oracle**: `Serializable` → Lock 전혀 사용하지 않음

---

## Dirty Read 허용

- SQL Server: `WITH(NOLOCK)` 또는 `Read Uncommitted` 격리 수준  
- **주의**: 제한적 사용 필요 (비일관성 발생 가능)

---

## 갱신 대상 식별 기준

- Oracle: `UPDATE` 시작 시점 기준 (조건 변경 시 재시작)
- SQL Server: 레코드 도달 시점 기준

> 격리 수준이 높을수록 일관성↑, 동시성↓ (MVCC는 해당 X)

---

## 동시성 제어 모델

- **비관적 동시성**: 읽을 때부터 Lock
- **낙관적 동시성**: 변경 시점 Lock 여부 확인

---

## WAIT / NOWAIT

- `SELECT FOR UPDATE`에서 사용
  - `WAIT n`: 최대 n초 기다림
  - `NOWAIT`: 즉시 실패

---

## Lost Update

- `COUNT(*)` 중간에 데이터 변경 → 변경 사항 반영 안 됨

---

## SnapShot Too Old

- 동일 블록 여러 번 액세스 시 발생
- 원인: 지연된 블록 클린아웃
- 해결: 대량 Update 후 Full Scan 주의, 클린아웃 유도

