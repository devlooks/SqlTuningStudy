
# Oracle 아키텍처 및 성능 정리

## 1. PGA (Program Global Area)

- **CGA**: Call까지 참조 시 데이터 할당 (Parse, Execute, Fetch Call)
- **UGA**: 전용 서버 방식 또는 MTS → 프로세스:세션 = 1:다

## 2. 세그먼트

- 테이블스페이스 내 존재, 여러 세그먼트 구성
- 데이터파일을 통해 저장
- 익스텐트의 집합이며, 연속된 블록
- 한 익스텐트의 블록은 동일 테이블 소속
- SQL Server: 한 익스텐트를 여러 오브젝트가 공유 가능

## 3. Logging

### Write Ahead Logging

- 블록 버퍼 변경 전 → Redo 로그 버퍼에 기록
- DBWR가 디스크에 기록 전, LGWR이 Redo 로그 기록 보장

### Fast Commit

- Redo 로그만 기록 → 빠르게 Commit 완료

### Delayed Block Clean Out

- 변경 블록 커밋 시점에 Clean Out(락 해제, 커밋 정보)
- 이후 처음 읽는 세션이 정리

## 4. 비용 모델

- 전통적 모델: I/O Call 횟수 기반
- 최신 CPU 모델: CPU 비용 + I/O 비용 → 여전히 I/O 비중 큼

> SQL 성능 저하의 대부분 원인: Disk I/O  
> 논리 I/O ↓ → Disk I/O ↓

## 5. 블록 단위 I/O

- OLTP: 블록 사이즈 작게
- OLAP/DW: MultiBlock I/O 단위 ↑ → 대용량 처리 효율 ↑

- Index Range Scan → Single Block I/O
- Table Full Scan, Index Fast Full Scan → Multi Block I/O

## 6. 대기 이벤트

- `latch: cache buffers chains`: 캐시 탐색 시 경합
- `buffer busy waits`: 다중 읽기/쓰기 요청으로 Lock 경합
- `log buffer space`: Redo 기록 전에 로그버퍼가 가득 참

## 7. 인덱스

### Range Scan 가능 조건

- 선두 컬럼 존재, 가공되지 않음
- `BETWEEN` 사용 추천 (LIKE, 부정형, 형변환 지양)

### 인덱스 설계 기준

- SQL 수행 빈도 ↑
- 저장 효율 고려
- 데이터량 ↓ → 인덱스 자유 생성 가능

> 인덱스 수 ↑ → DML 부하 ↑

## 8. 힌트 작성

- 테이블 Alias 존재 시 → 반드시 Alias 사용

## 9. 조인 전략

### Nested Loop Join

- 한 레코드씩 처리 → 부분 범위 처리에 유리
- Sort 연산 생략 가능

### Hash Join

- 등치 조건 필수
- Build Input에 중복값 많을 경우 비효율
- 해시 테이블 생성 후 NL 방식처럼 탐색

### Sort Merge Join

- 정렬 후 병합 조인
- 레코드 단위 X, 전체 집합 조인

## 10. 페이징 튜닝

1. 내부 쿼리: `ORDER BY`
2. 중간 단계: `ROWNUM` 처리
3. 외부: 조인, 사용자 함수, 스칼라, 최종 `ORDER BY`

> Oracle Batch I/O로 인해 순서 흐트러짐 방지 목적

## 11. Shared Pool

- **Dictionary Cache**: 테이블, 인덱스, 테이블스페이스 정보
- **Library Cache**: 실행 계획, PL/SQL, SQL 텍스트 캐싱

## 12. 바인드 변수

- 히스토그램 사용 X, 다른 통계정보 사용
- NDV 기반 → 균등 분포로 카디널리티 계산
- Bind Peeking → 실행계획 불안정성 초래
- `CURSOR_SHARING=FORCE`: 운영에서 비권장

## 13. 통계 정보

- 수집 목적: 실행 계획 안정성 향상
- 파싱, 최적화 시간에는 영향 X
- 통계정보 반영 O → 좋은 실행계획 수립 가능성 ↑
- 실행계획 공유/재사용과는 무관

## 14. 정렬과 집계

- 통계 집계 함수 사용 시 → Window Sort 발생

## 15. 파티셔닝과 Insert

- 해시 파티셔닝 + Insert → 성능 개선 없음 (느려짐)

## 16. Insert 및 로딩 방식

- Direct Path Write: `Exclusive TM Lock`
- 일반 Insert: `RX 모드 TM Lock`

### SQL*Loader (sqlldr)

- `direct=true` 옵션
- Parallel Insert → Direct Path Write
- CTAS → Direct Path Insert

## 17. 스칼라 서브쿼리

- 조인 변형일 뿐 → 표현 방식 차이
- User Call, Recursive Call 발생 X
- 네트워크 부하 절감 없음 → 성능에는 영향 有

## 18. 캐시 버퍼 히트율

```sql
(1 - disk / (query + current)) * 100
```

## 19. Parse 및 Cursor

- `Missing in library cache during parse = 1` → Hard Parsing
- Parse 100 → Soft Parsing 99
- Parse 1 / Execute 500 → Application 커서 캐싱

## 20. 파티션 전략

- 사용자 정의 그룹 → List 파티션
- `PQ_DISTRIBUTE(inner, outer, 방식)` 힌트로 병렬 조인 제어

## 21. Locking과 MVCC

- 전통 Locking: 공유 Lock → 동시성 낮음
- Oracle(MVCC):
  - 공유 Lock X → 동시성 ↑
  - Undo 데이터 → SQL 시작 시점 기준 일관성 유지
  - Undo 덮이면 SnapShot too old 발생

## 22. 응답 시간 분석

- **Response Time = CPU(Service) + Wait(Queue)**

### AWR vs Statspack

- AWR: DMA 방식으로 SGA 직접 접근
- Statspack: Dictionary 기반 → 비교적 구 방식

## 23. View Merge 방지

- View 내부 `ROWNUM` → View Merging 방지
- 힌트: `NO_MERGE`

## 24. 정렬 공간 설정

- `sort_area_size`: Sort Area 크기
- `work_area_size_policy=manual`: 수동 설정 필요

## 25. SQL 최적화 절차

1. **Parser**: 파싱 트리 생성
2. **Query Transformer**: 표준 형태로 변환
3. **Plan Generator / Estimator**: 후보 계획 생성 및 비용 산정
4. **Row-Source Generator**: 실행용 프로시저 포맷 생성
