## DML
  - select, Insert, Update, Delete

## DDL
  - create, alter, drop, rename

## DCL
  - grant, revoke

## TCL
  - commit, rollback

## 일반 집합 연산자
  - Union -> Union
  - Intersection -> Intersect
  - Product -> cross join
  - Except -> Minus

## 정규화
  - 정합성 확보 -> 불필요한 중복 줄이기
  - 외부키 -> 다른 테이블 기본기 사용관계

## ERD
  - 엔티티, 관계, 속성

## 합성 연산자
  - Oracle -> ||
  - SQL Server -> +
  - Concat 함수

## substr('SQL Expert', 5, 3) -> Exp
## substring('SQL Expert', 5, 3) -> Exp

## Case 문
```
select ename
  , case 
      when ~
      else ~
    end as ~
from t;
```

## NULL 함수
  - NVL, ISNULL(Expr1, Expr2) Expr1이 Null 일 경우 Expr2로
  - NULLIF(Expr1, Expr2) > Expr1과 Expr2가 같으면 Null
  - coalesce(Expr1, Expr2, Expr3) -> Null 이 아닌 Expr의 최초 값

## Group by 절과 having 절 순서 변경
  - 에러 X 동일 결과 출력
  - where -> 그룹핑전 필터링, having을 그룹핑 후 필터링

## 집계 함수
  - ISNULL(SAL, 0) -> 불필요한 연산 진행

## select 문장 식행 순서
  - from -> where -> group by -> having -> select -> order by

## Outer join 
  - (+) 컬럼이 기준 -> 해당 컬림 null 가능

## Inner join 
  - 내부 조인

## natural join 
  - 동일한 이름 갖는 모든 컬럼에 대해 Join (데이터 성격)
```
select ~ from A natural join B
```

## Using 조건절
  -> 같은 이름 컬럼 중 원하는 컬럼만 선택적 Equal Join
```
select ~ from A join B Using(deptno)
```

## Cross Join 
  - Product 개념

## 서브쿼리
  - 비연관 -> 메인 쿼리와 연관 X
  - 연관 -> 메인 쿼리와 연관 O
  - Single Row -> 항상 1건
  - Multi Row -> 여러건 (IN, ALL, ANY, EXISTS
  - Multi Col -> 실행 결과 여러 컬럼
    ```
    select ~ from ~ where (A, B) IN (select A, B ~ from ~)
    ```

## 연관 서브쿼리
  - 메인 쿼리에 존재하는 모든 행에 반복 수행

## 스칼러 서브쿼리
  - 메인 쿼리의 결과 건수 만큼 수행

## 뷰 
  - 독립성 -> 구조 변경, 응용프로그램 변경 X
  - 편리성 -> 복합질의 -> 단순 질의
  - 보안성 -> 뷰 생성시 컬럼 선택 가능

```
  create view vw_1 as select ~

  drop view vw_1;
```

## 집합 연산자의 결과 표시 HEADING 부분은 첫번째
  - SQL문에 사용된 ALIAS 적용
  - INTERSECT -> EXISTS, IN 으로 변경 가능

## 그룹함수
  - ROLLUP 함수
  - Grouping column -> N -> N + 1 (subTotal)
  - 순서 바뀌면 결과 변경 인수 주의

## Grouping 함수
  - 소계가 계산된 결과 Grouping(Expr) -> 1 로 출력 그외 결과 0

## Cube 함수
  - 다차원 집계
  - 시스템 부담
  - 컬럼 순서 상관 X
  - 2^n 승 결과

## Grouping Sets
  - 인수별 개별 집계
  - 순서 변경 해도 결과 그대로

## 윈도우 함수 
  - RANK 함수 -> 컬럼에 대한 순위 -> 1,2,2,4 ...
  - DENSE_RANK 함수 -> 동일 순위 하나의 건수 -> 1,2,2,3,4..
  - RANGE UNBOUNED PRECEDING
      - 전체 행 기준 파티션 첫번쨰 행까지 범위
  - ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
      - 현재 행 기준 앞뒤 1행씩
  - RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING
      - 현재행 + 50 ~ 150 이하
  - First_Value 함수
      - 파티션 별 가장 먼저 나온 값
      - ROWS UNBOUNED PRECEDING
        - 현재 행부터 파티션 첫번째 행
  - LAST_VALUE 함수
      - ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
        -  현재 행 포함 파티션 내 마지막 행까지
       
  - LAG 함수
    - 이전 몇번째 행 가져 올수 있다
      ex) LAG (SAL) OVER(ORDER BY ~ ) 위에서 1
      ex) LAG (SAL, 2, 0) OVER (ORDER BY ~ ) 위에서 2개
          - 이전 2번째 없으면 0 처리 한다.

  - lead 함수
    - 이후 몇번 째 행의 값
    - ex) LEAD (HIREDATE, 1)
        - 이후 1번째

## 그룹내 비율 함수 
  - ratio_to report -> 행별 컬럼값의 백분율 소수점
  - percent_rank -> 순서상 0~1 사이 값으로
  - cume_dist -> 누적 백분율
  - NTILE -> 전체 건수를 N등분

## Top N 쿼리
  - ROWNUM 
  - ROWNUM 슈도 컬럼
  - TOP 절
    - SELECT TOP(2) ~ FROM ~
   
## 계층형 질의 
  - start with -> 전개 시작 위치
  - connect by -> 다은 전개 자식 데이터
  - prior -> connect by 적에 사용, 읽는 컬럼 방향
    ex) fk = prior pk -> 순 방향
    ex) pk = prior fk -> 역 방향

  - NOCYCLE -> Cycle 이어도 에러 발생 안되도록
  - order siblings by -> 형재 노드 사이 정렬 수행
  - where 모든 전개 수행후 만족 데이터 필터링

  - Level -> 루트 1, 하위 2 리프까지 1씩 증가
  - connect_by_isleaf -> 리프데이터 1, 아니면 0
  - connect_by_iscycle -> cycle 옵션시 시용가능, 조장 존재 1, 없으면 0
  - sys_connect_by_path -> 루트 부터 현재행 결로 표시
  - connect_by_root -> 전개할 데이터의 루트 데이터 표시

## pivot 절
```
select *
from (select JOB, **DEPTNO**, SAL from emp)
PIVOT (SUM(SAL) for **deptno** in (10,20,30)
order by 1;
```

JOB|10|20|30
|---|---|---|---|
~~|~~|~~|~~|

```
select *
from (select to_char(hiredate, 'YYYY') as YYYY
            ,JOB
            ,DEPTNO
            ,SAL
      from emp)
pivot (sum(sal) for deptno in(10,20,30))
order by 1,2;
```

```
select *
from (select Job, deptno, sal from emp)
pivot (sum(sal) as sal for deptno in (10 as D10, 20 as D20, 30 as D30)
order by 1;
```

JOB|D10_SAL|D20_SAL|D30_SAL
|---|---|---|---|
~~|~~|~~|~~|

## ACID
  - Atomicity 원자성 : 성공 또는 전부 실패
  - Consistency 일관 : 트랜잭션 후 내용 잘못 되면 안된다.
  - Isolation 격리성 : 트랜잭션 도중 다른 트랜잭션 영향을 받지 않는다
  - durability 영속성 : db 반영 내역은 영구 저장 된다.

## Commit
  - 이전 상태
    - 변경 취소 -> 복구 가능
    - select 문장 -> 결과 확인 가능
    - 현재 사용자 수행 명령의 결과
    - Lock, 사용자 변경 못함 (동시에)
  - 이후 상태
    - 데이터 db에 반영
    - 이전 데이터 영원히 잃어 버림
    - 모든 사용자 Display
    - Lock 해제 행 조작 가능

## Mssql -> Auto Commit

## DDL
  - create, alter, drop, rename, truncate table
  - 자동 커밋(Auto commit)
  - 중간 접속 단절시, 트랜잭션 롤백

## create 문 
```
create table(
    ~~
  , constraint player_pk primary key(player_id)
  , constraint player_fk foreign key(team_id) references team(team_id)
)
```

## NULL
  - 아직 데이터가 없는 경우

## Modify column
  - 컬럼에 데이터 존재시 컬럼 크기 줄이는데 제약 있음 (기존 데이터 훼손 우려)

## Rename Column
  - 컬럼 관련 제약 조건도 자동 변경

## Drop constraint
  - Alter Table 테이블명 drop constraint 제약조건명
## Add constraint
  - Alter Table 테이블명 ADD constraint 제약조건명 제약조건(컬럼명)

## Rename Table
  - Rename 기존 테이블명 to 새로운 테이블 명
  - sp_rename '기존테이블명', '새로운 데이블 명'

## Drop Table
  - Drop table 테이블명(cascade, constraint)

## Truncate table
  - truncate table 테이블명;

## 정규 표현식

| 연산자 | 영문        | 설명                  |
|--------|-------------|-----------------------|
| .      | dot         | 모든 문자와 일치       |
| \|     | or          | 대체 문자 구분         |
| \\     | back slash  | 다음 문자를 일반 문자 취급 |

```
regexp_substr('aab', 'a.b') -> aab
regexp_substr('abb', 'a.b') -> abb 
regexp_substr('acb', 'a.b') -> acb
regexp_substr('adc', 'a.b') -> null

regexp_substr('a', 'a|b') -> a
regexp_substr('b', 'a|b') -> b
regexp_substr('c', 'a|b') -> null
regexp_substr('ab', 'ab|cd') -> ab
regexp_substr('cd', 'ab|cd') -> cd
regexp_substr('bc', 'ab|cd') -> null
regexp_substr('aa', 'a|aa') -> a
regexp_substr('aa', 'aa|a') -> aa

regexp_substr('a|b', 'a|b') -> a
regexp_substr('a|b', 'a\|b') -> a|b
```

| 연산자 | 영문        | 설명                  |
|--------|-------------|-----------------------|
| ^      | carrot         | 문자열 시작       |
| $     | dollar          | 문자열 끝         |
| ?     |   | 0 회 또는 1회 일치 |
| *     |   | 0 회 또는 그 이상 횟수 |
| +     |   | 1 회 또는 그 이상 횟수 |
| {m}     |   | m 회 일치 |
| {m,}   |   | 최소 m 회  |
| {,m}   |   | 최대 m 회 |
| {m,n}  |   | 최소 m, 최대 n 회 |

```
regexp_substr('ac', 'ab?c') -> ac matching : ac,abc
regexp_substr('abc', 'ab?c') -> abc matching : abc
regexp_substr('abbc', 'ab?c') -> null matching : ac, abc, abbc ...
regexp_substr('ac', 'ab*c') -> ac matching : ac,abc,abbc, abbbc ..
regexp_substr('abc', 'ab+c') -> abc matching : abc, abbc, abbbc ..

regexp_substr('ab', 'a{2}') -> null matching : aa
regexp_substr('aab', 'a{3}') -> null matching : aaa
regexp_substr('aaab', 'a{4,5}') -> null matching : aaaa, aaaaa

regexp_substr('ababc', '(ab)+c') ->ababc matching : abc, ababc ...
regexp_substr('ababc', 'ab+c') -> null matching : abc, abbc ...
regexp_substr('abd', 'a(b|c)d') -> abd matching : abd, acd 
regexp_substr('abd', 'ab|cd') -> ab matching : ab, cd

regexp_substr('abxab', '(ab|cd)x\1') -> abxab / ab 또는 cd 포함 x로 끝남 \n은 그룹의 n번째 다시 참조
regexp_substr('cdxcd', '(ab|cd)x\1') -> cdxcd
regexp_substr('abxef', '(ab|cd)x\1') -> null

// 1. (.*) 모든 문자를 그룹으로 잡음
// 2. \1 -> 역참조 그룹 찾음
// 3. 역참조 그룹 찾지 못함
// 4. (.*)에서 잡은 문자를 줄여서 다시 그룹으로 잡음
// 5. 역참조 가능한 그룹을 찾을때까지 줄여 나감 - 찾으면 찾는 대로 return 찾지 못하면 null
regexp_substr('ababab', '(.*)\1+') -> ababab

// [] 안에 있는 모든 문자는 의미를 두지않고 모두 문자열로 판단된다.
regexp_substr('ac', '[ab]c') -> ac, bc 
regexp_substr('bc', '[ab]c') -> bc 
regexp_substr('cc', '[ab]c') -> null 
regexp_substr('ac', '[^ab]c') -> null
regexp_substr('bc', '[^ab]c') -> null
regexp_substr('cc', '[^ab]c') -> cc 

regexp_substr('1a', '[0-9][a-z]') -> 1a
regexp_substr('9z', '[0-9][a-z]') -> 9z
regexp_substr('aA', '[^0-9][a-z]') -> aA
regexp_substr('Aa', '[^0-9][a-z]') -> null
```

| 연산자 | 설명        | 동일                  |
|--------|-------------|-----------------------|
| [:digit:]      | 숫자         | [0-9]       |
| [:lower:]     | 소문자          | [a-z]         |
| [:upper:]     | 대문자  | [A-Z] |
| [:alpha:]     | 영문자  | [a-zA-Z] |
| [:alnum:]     | 영문자와 숫자  | [0-9a-zA-Z] |
| [:xdigit:]     | 16진수  | [0-9a-fA-F] |
| [:punct:]     | 구두점 기호  | [^[:alnum:][:cntrl:]] |
| [:blank:]     | 공백 문자  |  |
| [:space:]     | 공간 문자  |  |

```
regexp_substr('gF1,', '[[:digit:]]') -> 1
regexp_substr('gF1,', '[[:alpha:]]') -> g
regexp_substr('gF1,', '[[:lower:]]') -> g
regexp_substr('gF1,', '[[:upper:]]') -> F
regexp_substr('gF1,', '[[:alnum:]]') -> g
regexp_substr('gF1,', '[[:xdigit:]]') -> F
regexp_substr('gF1,', '[[:punct:]]') -> ,
```

| 연산자 | 설명        | 동일                  |
|--------|-------------|-----------------------|
| \d      | 숫자                         | [[:digit:]]       |
| \D     | 숫자가 아닌 모든 문자          | [^[:digit:]]         |
| \w     | 숫자와 영문자(underbar 포함)   | [[:alnum:]_] |
| \W     | 숫자와 영문자가 아닌 모든 문자(underbar 제외)  | [^[:alnum:]_] |
| \s     | 공백 문자                      | [[:space:]]   |
| \S     | 곡백문자가 아닌 모든 문자        | [^[:space:]] |


```
regexp_substr('(650) 555-0100', '^\(\d{3}\) \d{3}-\d{4}$') -> (650) 555-0100
regexp_substr('650-555-0100', '^\(\d{3}\) \d{3}-\d{4}$') -> null
regexp_substr('b2b', '\w\d\D') -> b2b
regexp_substr('b2_', '\w\d\D') -> b2_
regexp_substr('b22', '\w\d\D') -> null

// \w+ 문자 1개 이상
// @ 그냥 문자
// \w+ 문자 1개 이상
// (\.\w+)+ -> (\. 리터럴 . 의미 문자 \w+ 문자 1회 이상)+ -> 패턴 1회 이상 
regexp_substr('jdoe@company.co.uk', '\w+@\w+(\.\w+)+')
regexp_substr('jdoe@company', '\w+@\w+(\.\w+)+') -> null

// \w+(to)\W(:)\s(공백)\w+(문자열)
regexp_substr('to: bill', '\w+\W\s\w+') -> to: bill
regexp_substr('to bill', '\w+\W\s\w+') -> null

// '\( -> 괄호 찾음
// \w(문자)
// \s(공백) /S(공백 아닌것)
// \w(문자)
// \s(문자) /S(공백 아닌것)
//  \) -> 괄호 찾음'
regexp_substr('(a b )', '\(\w\s\w\s\)') -> (a b )
regexp_substr('(a b )', '\(\w\S\w\S\)') -> null
regexp_substr('(a,b.)', '\(\w\s\w\s\)') -> null
regexp_substr('(a,b.)', '\(\w\S\w\S\)') -> (a,b.)
```

| 연산자 | 설명        | 
|--------|-------------|
| ??     | 0회 또는 1회 일치 |
| *?     | 0회 또는 그 이상의 횟수로 일치  |
| +?     | 1회 또는 그이상의 횟수로 일치   |
| {m}?   | m회 일치  | 
| {m,}?  | 최소 m회 일치| 
| {,m}?  | 최대 m회 일치 | 
| {m,n}? | 최소 m회, 최대 n회 일치|

```
regexp_substr('aaaa', 'a??aa') -> aa
regexp_substr('aaaa', 'a?aa') -> aaa

// '\w*?x\w'
// \w*? -> 문자열 최소한 0개 매칭
// x -> x 문자열
// \w 모든 문자열
regexp_substr('xaxbxc', '\w*?x\w') -> xa

// '\w*x\w'
// \w* -> 가능한 많이 문자열 잡고 시작
// x -> x 문자열
// \w 모든 문자열
regexp_substr('xaxbxc', '\w*x\w') -> xaxbxc

// '\w+?x\w'
// \w+? -> 가능한 가장 적게 문자열 잡고 시작
// x -> x문자열
// \w 모든 문자열
regexp_substr('abxcxd', '\w+?x\w') -> abxc

// '\w+x\w'
// \w+ -> 가능한한 모든 단어 잡고 시작
// x -> x문자열
// \w -> 한 문자
regexp_substr('abxcxd', '\w+x\w') -> abxcxd

regexp_substr('aaaa', 'a{2}?') -> aa
regexp_substr('aaaa', 'a{2}') -> aa
regexp_substr('aaaaa', 'a{2,}?') -> aa
regexp_substr('aaaaa', 'a{2,}') -> aaaaa
regexp_substr('aaaaa', 'a{2,4}?') -> aa
regexp_substr('aaaaa', 'a{2,4}') -> aaaa

// a.b -> a와 b 사이 모든 문자
regexp_substr('aab', 'a.b') -> aab
regexp_substr('abb', 'a.b') -> abb
regexp_substr('acb', 'a.b') -> acb
regexp_substr('adc', 'a.b') -> null
```


## regexp_ 함수 종류

- regexp_like : 패턴과 일치 true, 아니면 false
- regexp_replace : 일치 패턴을 원하는 형식으로 변경한다
- regexp_instr : pattern 시작 위치를 정수로 반환한다.
- regexp_count : pattern의 횟수를 반환한다.










