
## 1. DML
- select, Insert, Update, Delete  

🔵 **보완**
| 분류 | 명령어 | 설명 |
|------|--------|------|
| **DML** | SELECT, INSERT, UPDATE, DELETE | 데이터 조작어 (데이터 조회 및 수정) |
※ `DROP`, `TRUNCATE`는 DDL → **자동 COMMIT 발생**, ROLLBACK 불가  

---

## 2. DDL
✅ 개념
- CREATE : 새로운 데이터베이스 객체(테이블, 뷰, 인덱스 등) 생성
- ALTER : 기존 객체의 구조 변경
- DROP : 데이터 + 구조 + 제약조건 모두 제거 (객체 완전 제거)
- 실행 즉시 자동 COMMIT 발생 (ROLLBACK 불가)
- 제약조건 선언 가능
- create, alter, drop, rename  

🔵 **보완**
| 분류 | 명령어 | 설명 |
|------|--------|------|
| **DDL** | CREATE, ALTER, DROP, RENAME | 데이터 정의어 (객체 생성 및 구조 변경) |

### Create 

```
CREATE TABLE EMP (
  EMPNO     NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY,
  ENAME     VARCHAR2(20) NOT NULL,
  JOB       VARCHAR2(20),
  DEPTNO    NUMBER(2) CONSTRAINT FK_EMP_DEPT REFERENCES DEPT(DEPTNO)
);
```
| 포인트     | 설명                                                            |
| ------- | ------------------------------------------------------------- |
| 자동 커밋   | CREATE는 DDL → 트랜잭션에 포함되지 않음                                   |
| 제약조건 명시 | PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL 가능          |
| 컬럼 기본값  | `DEFAULT` 키워드로 지정 가능                                          |
| 테이블 복사  | `CREATE TABLE NEW AS SELECT * FROM OLD;` (CTAS) — 제약조건 복사 안 됨 |

### ALTER 

```
-- 컬럼 추가
ALTER TABLE EMP ADD (EMAIL VARCHAR2(50));

-- 컬럼 수정 (자료형 변경)
ALTER TABLE EMP MODIFY (ENAME VARCHAR2(40));

-- 컬럼 삭제
ALTER TABLE EMP DROP COLUMN EMAIL;

-- 제약조건 추가
ALTER TABLE EMP ADD CONSTRAINT UK_EMP_ENAME UNIQUE(ENAME);

-- 제약조건 삭제
ALTER TABLE EMP DROP CONSTRAINT UK_EMP_ENAME;
```

| 포인트      | 설명                                                 |
| -------- | -------------------------------------------------- |
| 크기 축소 불가 | 컬럼 내 데이터 존재 시 줄이기 불가 (데이터 손실 위험)                   |
| 컬럼명 변경   | `ALTER TABLE EMP RENAME COLUMN ENAME TO EMP_NAME;` |
| 제약조건 변경  | DROP 후 ADD로만 가능 (직접 수정 불가)                         |
| 자동 커밋    | ALTER도 DDL → ROLLBACK 불가                           |


### Drop 
```
DROP TABLE EMP CASCADE CONSTRAINT;
```
| 포인트                               | 설명                 |
| --------------------------------- | ------------------ |
| CASCADE CONSTRAINT                | 외래키 종속 관계가 있을 때 사용 |
| ROLLBACK 불가                       | 실행 즉시 커밋됨          |
| DROP VIEW / INDEX / SEQUENCE 도 가능 | 모든 객체 삭제용          |
| 휴지통 기능 (Oracle 10g~)              | `PURGE` 옵션 시 완전 삭제 |

```
DROP TABLE EMP CASCADE CONSTRAINT;
```
| 포인트                               | 설명                 |
| --------------------------------- | ------------------ |
| CASCADE CONSTRAINT                | 외래키 종속 관계가 있을 때 사용 |
| ROLLBACK 불가                       | 실행 즉시 커밋됨          |
| DROP VIEW / INDEX / SEQUENCE 도 가능 | 모든 객체 삭제용          |
| 휴지통 기능 (Oracle 10g~)              | `PURGE` 옵션 시 완전 삭제 |


### Rename
```
RENAME EMP TO EMP_OLD;
```
| 포인트           | 설명                           |
| ------------- | ---------------------------- |
| 권한 필요         | 대상 객체의 소유자만 가능               |
| 제약조건명 자동 변경   | 관련 제약조건명도 함께 변경              |
| SQL Server 문법 | `sp_rename 'EMP', 'EMP_OLD'` |
| 데이터 영향 없음     | 구조와 내용은 동일, 이름만 변경           |



---

## 3. DCL

- grant, revoke
    
🔵 **보완**
| 분류 | 명령어 | 설명 |
|------|--------|------|
| **DCL** | GRANT, REVOKE | 권한 부여 및 회수 |


### GRANT
✅ 개념
- 사용자에게 객체나 시스템 권한을 부여하는 명령어
- 실행 즉시 자동 COMMIT (ROLLBACK 불가)
- 보안, 접근 제어, 사용자 관리 영역에서 매우 중요
```
-- 특정 객체에 대한 권한 부여
GRANT SELECT, INSERT ON EMP TO SCOTT;

-- 여러 사용자 동시 부여
GRANT SELECT ON EMP TO SCOTT, SMITH, JONES;

-- 다른 사용자에게 재부여 허용
GRANT SELECT ON EMP TO SCOTT WITH GRANT OPTION;

-- 시스템 권한 부여 (DBA용)
GRANT CREATE TABLE, CREATE VIEW TO HR;

-- SCOTT은 EMP 테이블을 SELECT/UPDATE 가능
-- WITH GRANT OPTION으로 인해 다른 사용자에게도 동일 권한을 부여할 수 있음
GRANT SELECT, UPDATE ON EMP TO SCOTT WITH GRANT OPTION;
```
| 포인트               | 설명                                            |
| ----------------- | --------------------------------------------- |
| ROLLBACK 불가       | DCL 명령은 즉시 반영된다.                              |
| WITH GRANT OPTION | 권한을 부여받은 사용자가 다른 사용자에게 재부여 가능                 |
| ALL PRIVILEGES    | 모든 권한 부여 (예: GRANT ALL ON EMP TO SCOTT)       |
| PUBLIC            | 모든 사용자에게 권한 부여                                |
| 시스템 권한과 객체 권한 구분  | CREATE TABLE → 시스템 권한 / SELECT ON EMP → 객체 권한 |

### REVOKE (권한 회수)

✅ 개념
- 이전에 부여된 권한을 회수하는 명령어
- 역시 자동 COMMIT 발생
```
-- 특정 사용자 권한 회수
REVOKE SELECT, INSERT ON EMP FROM SCOTT;

-- 여러 사용자 권한 회수
REVOKE ALL ON EMP FROM SCOTT, SMITH;

-- GRANT OPTION으로 부여된 권한을 연쇄 회수
REVOKE GRANT OPTION FOR SELECT ON EMP FROM SCOTT;
```

| 포인트                  | 설명                                     |
| -------------------- | -------------------------------------- |
| GRANT OPTION으로 받은 권한 | REVOKE 시 **연쇄 회수 (Cascade revoke)** 가능 |
| REVOKE는 GRANT의 반대    | 부여된 권한을 취소                             |
| PUBLIC 권한 회수         | `REVOKE SELECT ON EMP FROM PUBLIC;`    |
| ROLLBACK 불가          | DCL 명령은 즉시 적용                          |

### 차이점

| 구분   | GRANT             | REVOKE          |
| ---- | ----------------- | --------------- |
| 기능   | 권한 부여             | 권한 회수           |
| 트랜잭션 | 자동 COMMIT         | 자동 COMMIT       |
| 옵션   | WITH GRANT OPTION | CASCADE (연쇄 회수) |
| 대상   | 사용자 / PUBLIC      | 사용자 / PUBLIC    |
| 주의점  | ROLLBACK 불가       | 회수 시 권한 체인 주의   |

### 포인트 
| 출제 포인트                   | 핵심 개념                                |
| ------------------------ | ------------------------------------ |
| GRANT 즉시 반영              | DCL은 트랜잭션 제어를 받지 않음                  |
| WITH GRANT OPTION        | 재부여 가능 여부를 묻는 문제                     |
| REVOKE WITH GRANT OPTION | 연쇄 회수 여부 확인                          |
| PUBLIC 키워드               | 전체 사용자 대상                            |
| 객체 vs 시스템 권한 구분          | CREATE TABLE(시스템), SELECT ON EMP(객체) |

---

## 4. TCL

| 항목           | 설명                                            |
| ------------ | --------------------------------------------- |
| **트랜잭션**     | 하나의 논리적 작업 단위 (여러 SQL문을 묶어서 처리)               |
| **시작 시점**    | 첫 번째 DML(INSERT, UPDATE, DELETE) 실행 시 자동 시작   |
| **종료 시점**    | COMMIT 또는 ROLLBACK 수행 시                       |
| **DDL 실행 시** | 자동 COMMIT 발생 (ROLLBACK 불가)                    |
| **ACID 원칙**  | Atomicity, Consistency, Isolation, Durability |


- commit, rollback  

🔵 **보완**
| 분류 | 명령어 | 설명 |
|------|--------|------|
| **TCL** | COMMIT, ROLLBACK, SAVEPOINT | 트랜잭션 제어어 (일괄 처리 단위 관리) |

### COMMIT
✅ 개념
- 트랜잭션 내 변경 내용을 영구 반영
- 데이터베이스에 저장되어 다른 사용자에게도 보임
- COMMIT 이후에는 ROLLBACK 불가
- COMMIT 시점 이후의 SAVEPOINT는 무효화

```
COMMIT;
```

| 항목           | 설명                       |
| ------------ | ------------------------ |
| 변경 사항 영구 저장  | 데이터베이스에 반영됨              |
| LOCK 해제      | 해당 행 또는 테이블에 걸린 락 해제     |
| 다른 사용자 접근 가능 | 변경 내용 공유 가능              |
| 복구 불가        | UNDO 영역 삭제 → ROLLBACK 불가 |

### ROLLBACK

✅ 개념
- 트랜잭션 내의 변경 내용 취소
- 마지막 COMMIT 시점까지 복구
- DDL에는 적용 불가
```
ROLLBACK;                 -- 전체 취소
ROLLBACK TO SAVEPOINT A;  -- 특정 지점까지 취소
```
| 항목              | 설명                          |
| --------------- | --------------------------- |
| 변경사항 복구         | COMMIT 이전의 상태로 복원           |
| LOCK 해제         | 트랜잭션 종료 시점에 해제              |
| DDL 복구 불가       | CREATE, DROP 등은 ROLLBACK 불가 |
| SAVEPOINT 사용 가능 | 부분 복구 시 유용                  |

### SAVEPOINT (부분 복구 지점 설정)
```
SAVEPOINT SP1;
UPDATE EMP SET SAL = SAL*1.1;
ROLLBACK TO SP1;
```

| 항목            | 설명                |
| ------------- | ----------------- |
| 트랜잭션 내부 지점 설정 | 특정 시점으로 되돌아갈 수 있음 |
| COMMIT 수행 시   | 모든 SAVEPOINT 무효화  |
| 부분 취소 가능      | ROLLBACK TO 사용    |

| 주제        | 자주 묻는 포인트      | 예시                              |
| --------- | -------------- | ------------------------------- |
| COMMIT    | 자동 커밋 발생 여부    | CREATE TABLE 후 ROLLBACK 가능? → ❌ |
| ROLLBACK  | 복구 가능 범위       | COMMIT 후 변경 복구 가능? → ❌          |
| SAVEPOINT | 부분 복구          | ROLLBACK TO SAVEPOINT A → 부분 취소 |
| LOCK 해제   | COMMIT 시점      | COMMIT 후 다른 세션 접근 가능            |
| DDL 영향    | DDL은 자동 COMMIT | DROP TABLE 후 복구 불가              |

---

## 5. 일반 집합 연산자
- Union -> Union  
- Intersection -> Intersect  
- Product -> cross join  
- Except -> Minus  

🔵 **보완**
- SQL 집합 연산자:
  - `UNION`: 중복 제거  
  - `UNION ALL`: 중복 허용  
  - `INTERSECT`: 교집합  
  - `EXCEPT` / `MINUS`: 차집합  
- 집합 연산자는 **위 → 아래 순서로 실행**됨  
- 결과의 컬럼명은 **첫 번째 SELECT 문 기준**

| 구분          | ANSI 표준     | Oracle       | 설명                                  |
| ----------- | ----------- | ------------ | ----------------------------------- |
| 합집합         | `UNION`     | `UNION`      | 두 집합의 모든 행을 결합 (중복 제거)              |
| 합집합 (중복 포함) | `UNION ALL` | `UNION ALL`  | 중복 행도 포함                            |
| 교집합         | `INTERSECT` | `INTERSECT`  | 두 SELECT 결과에 공통으로 존재하는 행            |
| 차집합         | `EXCEPT`    | `MINUS`      | 첫 번째 SELECT 결과에서 두 번째 SELECT 결과를 제외 |
| 곱집합         | -           | `CROSS JOIN` | 모든 행의 조합 (Cartesian Product)        |

### UNION ALL / UNION
- 컬럼 개수와 데이터 타입이 동일해야 함
- ORDER BY는 마지막 SELECT 문 뒤에만 사용 가능

```
SELECT DEPTNO FROM EMP
UNION
SELECT DEPTNO FROM DEPT;
// 중복 부서번호는 1회만 표시됨 (UNION → 중복 제거)

SELECT DEPTNO FROM EMP
UNION ALL
SELECT DEPTNO FROM DEPT;
//중복 부서번호도 모두 표시됨 (UNION ALL → 중복 허용)
```
- 컬럼 개수와 데이터 타입이 동일해야 함
- ORDER BY는 마지막 SELECT 문 뒤에만 사용 가능

### INTERSECT (교집합)
```
SELECT DEPTNO FROM EMP
INTERSECT
SELECT DEPTNO FROM DEPT;
// 두 쿼리 결과에서 공통으로 존재하는 DEPTNO만 반환
```

- INTERSECT는 EXISTS나 IN으로 대체 가능
```
SELECT DEPTNO FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT);
// 집합 연산자는 자동으로 중복 제거 수행
```

---

## 6. 정규화
- 정합성 확보 → 불필요한 중복 줄이기  
- 외부키 → 다른 테이블 기본키 사용관계

## 개념

| 구분    | 내용                                                                |
| ----- | ----------------------------------------------------------------- |
| 정의    | 데이터의 **일관성(정합성)** 확보를 위해 **불필요한 중복을 제거**하고 **데이터 종속성을 최소화**하는 과정  |
| 목적    | - 데이터 중복 최소화<br>- 이상(Anomaly: 삽입·수정·삭제 이상) 제거<br>- 데이터 구조의 일관성 확보 |
| 기본 원리 | 하나의 사실은 한 곳에만 저장하도록 구조화                                           |
| 결과    | 테이블이 더 작고, 관계가 명확해짐 (JOIN이 증가할 수 있음)                              |

### 이상현상 
| 구분                | 설명                          | 예시                                         |
| ----------------- | --------------------------- | ------------------------------------------ |
| 삽입 이상 (Insertion) | 일부 속성 값이 없어 새 데이터를 추가할 수 없음 | 학생 정보와 강의 정보가 한 테이블에 있을 경우, 강의 없는 학생 추가 불가 |
| 수정 이상 (Update)    | 중복 데이터 수정 시 일부만 수정되어 불일치 발생 | 학생 주소 변경 시 여러 행 수정 필요                      |
| 삭제 이상 (Deletion)  | 일부 데이터 삭제 시 다른 정보도 함께 손실    | 특정 강좌 삭제 시 학생 정보도 같이 삭제됨                   |

### 정규화 단계별

| 단계   | 이름         | 핵심 조건                                      | 제거되는 종속성 | 예시                                   |
| ---- | ---------- | ------------------------------------------ | -------- | ------------------------------------ |
| 1NF  | 제1정규형      | **반복 속성 제거**, 모든 속성이 **원자값(Atomic Value)** | 반복 그룹    | 한 행에 여러 전화번호 저장 금지                   |
| 2NF  | 제2정규형      | **부분 함수 종속 제거** (기본키의 일부에 종속된 속성 제거)       | 부분 종속    | 복합키 중 일부 키에 종속된 컬럼 제거                |
| 3NF  | 제3정규형      | **이행 함수 종속 제거** (비키 → 비키 종속 제거)            | 이행 종속    | DEPTNAME이 DEPTNO를 통해 EMP에 종속되는 경우 분리 |
| BCNF | 보이스-코드 정규형 | **모든 결정자가 후보키**                            | 결정자 이상   | 후보키 외 결정자 제거                         |
| 4NF  | 제4정규형      | **다치 종속 제거**                               | 다치 종속    | 한 학생이 여러 과목·동아리 동시에 가질 때 분리          |
| 5NF  | 제5정규형      | **조인 종속 제거**                               | 조인 종속    | 테이블 재조합 시 정보 손실 없는 구조                |

### 비정규화 

| 구분 | 설명                               |
| -- | -------------------------------- |
| 정의 | 정규화된 구조를 **성능 개선 목적으로 의도적으로 결합** |
| 목적 | 조인 감소, 응답속도 향상                   |
| 주의 | 데이터 중복 증가, 무결성 유지 어려움            |
| 예시 | EMP와 DEPT를 조인한 결과를 하나의 테이블로 유지   |

### SQLP 실전 포인트 요약

| 구분   | 주요 내용     | 키워드          |
| ---- | --------- | ------------ |
| 1NF  | 원자값, 반복 컬럼 제거  | 원자값          |
| 2NF  | 부분 종속 제거 (복합키 일부 종속)   | 복합키 일부 종속    |
| 3NF  | 이행 종속 제거 (비키가 다른 비키 결정)  | 비키→비키 종속     |
| BCNF | 결정자 이상 제거(모든 결정자는 후보키 ) | 모든 결정자=후보키   |
| 4NF  | 다치 종속 제거  | 여러 독립적 다치 속성 |
| 5NF  | 조인 종속 제거  | 정보 손실 없는 분해  |
| 비정규화 | 성능 향상 목적, 정규화된 구조 일부 해제  | 조인 감소, 중복 허용 |
| 외래키  | 참조 무결성 확보용              |

---

## 7. ERD
- 엔티티, 관계, 속성

| 구분                   | SQL 관점 설명                           |
| -------------------- | ----------------------------------- |
| **엔티티(Entity)**      | SQL에서 `CREATE TABLE`로 구현되는 **테이블**  |
| **속성(Attribute)**    | `CREATE TABLE` 내의 **컬럼(열)**         |
| **관계(Relationship)** | **PK-FK 제약조건**으로 표현됨 (JOIN의 논리적 근거) |

### 엔티티
```
CREATE TABLE DEPT (
  DEPTNO NUMBER(2) PRIMARY KEY,
  DNAME  VARCHAR2(14),
  LOC    VARCHAR2(13)
);
// 엔티티는 CREATE TABLE로 구현
// PRIMARY KEY 제약조건 필수
// ERD의 “식별자” = SQL의 “기본키(PK)”
```

### 관계

| 관계 형태 | SQL 표현               | 설명               |
| ----- | -------------------- | ---------------- |
| 1:1   | UNIQUE + FOREIGN KEY | 부서-부서장           |
| 1:N   | FOREIGN KEY          | 부서-사원            |
| N:M   | 별도 교차 테이블 생성         | 학생-과목 → 수강테이블 생성 |

- FK는 반드시 다른 테이블의 PK를 참조
- 부모 데이터 삭제 시 자식 존재 → 에러 발생 (ON DELETE CASCADE 옵션 예외)

```
CREATE TABLE EMP (
  EMPNO   NUMBER(4) PRIMARY KEY,
  ENAME   VARCHAR2(20),
  DEPTNO  NUMBER(2),
  CONSTRAINT FK_EMP_DEPT FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO)
);
```

### 속성 

```
CREATE TABLE EMP (
  EMPNO   NUMBER(4),
  ENAME   VARCHAR2(20) NOT NULL,
  SAL     NUMBER(7,2) DEFAULT 0,
  HIREDATE DATE,
  DEPTNO  NUMBER(2)
);
```

| 속성 유형    | SQL 표현            | 설명              |
| -------- | ----------------- | --------------- |
| 기본 속성    | 일반 컬럼             | 사원명, 급여         |
| 파생 속성    | SQL 계산 결과         | 급여합계 = SUM(SAL) |
| 외래 속성    | FK 컬럼             | DEPTNO 등        |
| NOT NULL | NULL 불허, 반드시 값 필요 |                 |
| DEFAULT  | 기본값 자동 입력         |                 |


### ERD → SQL 변환 요약

| ERD 구성요소 | SQL 구현 방법        | 예시                                   |
| -------- | ---------------- | ------------------------------------ |
| 엔티티      | CREATE TABLE     | CREATE TABLE EMP ...                 |
| 속성       | 컬럼 정의            | ENAME VARCHAR2(20)                   |
| 기본키      | PRIMARY KEY 제약조건 | CONSTRAINT PK_EMP PRIMARY KEY(EMPNO) |
| 관계       | FOREIGN KEY 제약조건 | REFERENCES DEPT(DEPTNO)              |
| 다대다      | 교차 테이블 추가        | ENROLL(STUD_ID, COURSE_ID)           |

### 실전 포인트
| 구분           | 출제 포인트                          | 예시                                         |
| ------------ | ------------------------------- | ------------------------------------------ |
| CREATE TABLE | 컬럼/제약조건 문법                      | PRIMARY, FOREIGN, DEFAULT, NULL            |
| 제약조건         | PK, FK, UNIQUE, CHECK, NOT NULL | FK는 부모 PK 참조                               |
| 관계 이해        | JOIN 근거로 활용                     | EMP.DEPTNO = DEPT.DEPTNO                   |
| 무결성          | 참조 무결성 제약                       | 부모 삭제 시 제약 발생                              |
| 조인 연계        | ERD → JOIN 문 작성                 | SELECT ENAME, DNAME FROM EMP JOIN DEPT ... |

---

## 8. 합성 연산자
- Oracle → `||`  
- SQL Server → `+`  
- `Concat()` 함수

🔵 **보완**
- 문자열 함수  
  - `SUBSTR('문자열', 8, 4)` → 8번째 문자부터 4개 추출  
  - `TRIM(문자)` → 양쪽 문자 제거  
  - `LTRIM` / `RTRIM` → 앞/뒤 문자 제거  
  - SQL Server에서는 `LTRIM`, `RTRIM`이 공백만 제거 가능

| DBMS                   | 문자열 결합 연산자    | 예시                         | 결과           |
| ---------------------- | ------------- | -------------------------- | ------------ | 
| **Oracle**             | `\|\|`        | `'SQL' \|\| ' Expert'` |  `SQL Expert` |
| **SQL Server**         | `+`           | `'SQL' + ' Expert'`        | `SQL Expert` |    
| **MySQL / PostgreSQL** | `CONCAT()` 함수 | `CONCAT('SQL', ' Expert')` | `SQL Expert` |  

  
---
## 9. substr
  - substr('SQL Expert', 5, 3) → Exp  
  - substring('SQL Expert', 5, 3) → Exp  

| DBMS                   | 함수명                        | 인덱스 시작 | 예시                              | 결과    |
| ---------------------- | -------------------------- | ------ | ------------------------------- | ----- |
| **Oracle**             | `SUBSTR(문자열, 시작위치 [, 길이])` | 1부터 시작 | `SUBSTR('SQL Expert', 5, 3)`    | `Exp` |
| **SQL Server / MySQL** | `SUBSTRING(문자열, 시작위치, 길이)` | 1부터 시작 | `SUBSTRING('SQL Expert', 5, 3)` | `Exp` |

- 두 함수는 기능이 동일하나 DBMS 이름이 다름
- 시작 인덱스는 1부터 (0 아님)

### 매개변수 설명

| 매개변수  | 설명            | 예시                |
| ----- | ------------- | ----------------- |
| 문자열   | 추출 대상 문자열     | `'SQL Expert'`    |
| 시작 위치 | 추출 시작 지점      | `5` → 5번째 문자(E)부터 |
| 길이    | (선택) 추출할 문자 수 | `3` → `Exp` 반환    |

### 비슷한 함수

| 함수          | 설명          | 예시                         | 결과     |
| ----------- | ----------- | -------------------------- | ------ |
| **INSTR**   | 특정 문자 위치 반환 | `INSTR('SQL Expert', 'E')` | `5`    |
| **LENGTH**  | 문자열 길이 반환   | `LENGTH('SQL')`            | `3`    |
| **TRIM**    | 양쪽 문자 제거    | `TRIM(' A ')`              | `A`    |
| **REPLACE** | 특정 문자열 치환   | `REPLACE('ABCD','B','X')`  | `AXCD` |

```
-- Oracle
SELECT SUBSTR('SQL Expert', 5, 3) FROM dual;     -- 결과: Exp
SELECT SUBSTR('SQL Expert', -3) FROM dual;        -- 결과: ert (뒤에서 3번째부터 끝까지)

-- SQL Server
SELECT SUBSTRING('SQL Expert', 5, 3);             -- 결과: Exp
SELECT SUBSTRING('SQL Expert', LEN('SQL Expert')-2, 3); -- 결과: ert

```
EX)
| SQL                            | 결과    | 설명                     |
| ------------------------------ | ----- | ---------------------- |
| `SUBSTR('SQL Expert', -3)`     | `ert` | 뒤에서 3번째(e)부터 끝까지       |
| `SUBSTR('SQL Expert', -4, 2)`  | `pe`  | 뒤에서 4번째(p)부터 2글자       |
| `SUBSTR('SQL Expert', -6, 3)`  | `Exp` | 뒤에서 6번째(E)부터 3글자       |
| `SUBSTR('SQL Expert', -10, 3)` | `SQL` | 문자열 전체 길이 -10 = 시작위치 1 |

---

## 10. Case 문
```sql
SELECT ename,
       CASE 
         WHEN ~ THEN ~
         ELSE ~
       END AS ~
FROM t;

CASE 컬럼명
  WHEN 비교값1 THEN 결과1
  WHEN 비교값2 THEN 결과2
  ELSE 기본값
END

SELECT DEPTNO,
       CASE DEPTNO
         WHEN 10 THEN 'ACCOUNTING'
         WHEN 20 THEN 'RESEARCH'
         WHEN 30 THEN 'SALES'
         ELSE 'ETC'
       END AS DEPT_NAME
FROM EMP;

SELECT ENAME,
       CASE
         WHEN SAL >= 3000 THEN 'HIGH'
         WHEN SAL >= 2000 THEN 'MID'
         ELSE 'LOW'
       END AS SAL_GRADE
FROM EMP;
```

| 항목             | 요약                                                   |
| -------------- | ---------------------------------------------------- |
| CASE 구조        | WHEN ~ THEN ~ ELSE ~ END                             |
| 종료 키워드         | END                                                  |
| ELSE 생략        | NULL 반환                                              |
| 평가 순서          | 위 → 아래, 첫 TRUE 적용                                    |
| 데이터 타입         | 모든 THEN 결과 타입 동일                                     |
| 사용 위치          | SELECT / WHERE / HAVING / ORDER BY / UPDATE / DELETE |
| CASE vs DECODE | CASE: ANSI 표준 + 범위 비교 가능 / DECODE: Oracle 전용         |
| 실무 활용          | 조건별 출력, 정렬, 집계 제어                                    |

---

## 11. NULL 함수
- NVL, ISNULL(Expr1, Expr2) Expr1이 Null 일 경우 Expr2로  
- NULLIF(Expr1, Expr2) → Expr1과 Expr2가 같으면 Null  
- coalesce(Expr1, Expr2, Expr3) → Null이 아닌 Expr의 최초 값  

🔵 **보완**
| 함수                | 설명               | DBMS       | 예시                   | 결과   |
| ----------------- | ---------------- | ---------- | -------------------- | ---- |
| `NVL(A,B)`        | A가 NULL이면 B      | Oracle     | `NVL(NULL,10)`       | 10   |
| `ISNULL(A,B)`     | A가 NULL이면 B      | SQL Server | `ISNULL(NULL,10)`    | 10   |
| `COALESCE(A,B,C)` | 첫 NULL 아닌 값 반환   | ANSI       | `COALESCE(NULL,5,7)` | 5    |
| `NULLIF(A,B)`     | A=B면 NULL, 아니면 A | ANSI       | `NULLIF(100,100)`    | NULL |


---

## 12. Group by 절과 having 절 순서 변경
- 에러 X, 동일 결과 출력  
- where → 그룹핑 전 필터링, having → 그룹핑 후 필터링  

🔵 **보완**
- `WHERE`절에서는 집계함수 사용 불가 → `HAVING`으로 조건 처리  
- `GROUP BY NULL` → 불가  
- `GROUP BY ALIAS` → 별칭 사용 불가 (컬럼명만 가능)  
- 집계함수와 WHERE 병용 불가 (`HAVING` 사용)

| 항목                       | 허용 여부                | 설명                         |
| ------------------------ | -------------------- | -------------------------- |
| `HAVING` 단독 사용 (집계함수 포함]) | ✅ 가능                 | 전체를 1그룹으로 보고 조건 평가         |
| `HAVING` 단독 사용 (집계함수 없음) | ⚠️ 일부 DB만 가능         | Oracle은 허용, SQL Server는 오류 |
| `WHERE` 없이 `HAVING`      | ✅ 가능                 | 그룹 필터로만 조건 평가              |
| `GROUP BY` 없이 `HAVING`   | ✅ 가능                 | 전체 1그룹으로 간주                |
| `HAVING`만 사용 시 결과        | 조건 만족 시 1행, 불만족 시 0행 |                            |
| `HAVING을 GROUP BY 앞에 사용` | 불가능 | 문법 에러 발생|
---

## 13. 집계 함수
- ISNULL(SAL, 0) → 불필요한 연산 진행  

🔵 **보완**
| 함수 | 설명 |
|------|------|
| `SUM`, `AVG`, `MAX`, `MIN`, `COUNT` | 기본 집계함수 |
| `COUNT(*)` | NULL 포함 전체 행 수 |
| `COUNT(컬럼)` | NULL 제외 행 수 |


### 주요 집계함수
| 함수          | 의미               | NULL 처리 | 예시            | 결과               |
| ----------- | ---------------- | ------- | ------------- | ---------------- |
| `COUNT(*)`  | 전체 행 수 (NULL 포함) | 포함      | `COUNT(*)`    | 모든 행             |
| `COUNT(컬럼)` | NULL 제외 행 수      | 무시      | `COUNT(comm)` | comm이 NULL이 아닌 행 |
| `SUM(컬럼)`   | 합계               | 무시      | `SUM(sal)`    | 급여 합계            |
| `AVG(컬럼)`   | 평균               | 무시      | `AVG(sal)`    | 급여 평균            |
| `MAX(컬럼)`   | 최댓값              | 무시      | `MAX(sal)`    | 최대 급여            |
| `MIN(컬럼)`   | 최솟값              | 무시      | `MIN(sal)`    | 최소 급여            |

### DISTINCT 옵션
```
SELECT COUNT(DISTINCT deptno) AS 부서수 FROM emp;
```
| 항목                   | 설명                                                       |
| -------------------- | -------------------------------------------------------- |
| `COUNT(DISTINCT 컬럼)` | 중복 제외한 고유 값 개수                                           |
| `SUM(DISTINCT 컬럼)`   | 중복 제외 후 합산                                               |
| `AVG(DISTINCT 컬럼)`   | 중복 제외 후 평균                                               |
| ⚠️ 제한                | 여러 컬럼 동시 DISTINCT는 DBMS마다 제한 존재 (Oracle 11g부터 1개 컬럼만 허용) |


### 집계 함수와 NULL 처리

| 함수                | NULL 포함 여부                    | 예시                  | 결과 |
| ----------------- | ----------------------------- | ------------------- | -- |
| `COUNT(*)`        | 포함                            | NULL 값 있어도 전체 행 카운트 |    |
| `COUNT(컬럼)`       | 제외                            | NULL은 세지 않음         |    |
| `SUM/AVG/MAX/MIN` | 제외                            | NULL은 무시하고 계산       |    |
| **주의**            | NVL 등으로 NULL을 0으로 변환 시 값이 달라짐 | `AVG(NVL(comm,0))`  |    |

```
SELECT COUNT(comm), COUNT(*), AVG(comm), AVG(NVL(comm,0))
FROM emp;
```
| 함수               | 설명           | 결과    |
| ---------------- | ------------ | ----- |
| COUNT(comm)      | NULL 제외      | 4     |
| COUNT(*)         | 전체 행         | 14    |
| AVG(comm)        | NULL 제외 평균   | 550   |
| AVG(NVL(comm,0)) | NULL을 0으로 간주 | 157.1 |

### 집계 함수의 중첩 (Nested Aggregation

- ❌ 단일 SELECT 수준에서 중첩 불가 (SUM(AVG(...))

### 집계 함수 사용시 주의사항
| 항목                                       | 설명 |
| ---------------------------------------- | -- |
| SELECT 절에 집계함수 외 컬럼 존재 → 반드시 GROUP BY 필요 |    |
| WHERE 절에서는 집계함수 사용 불가 (HAVING 사용)        |    |
| GROUP BY 없는 집계함수 → 전체 테이블 1그룹 처리         |    |
| DISTINCT 지정 시 중복 제거                      |    |
| COUNT(*)는 NULL 포함, COUNT(컬럼)는 NULL 제외    |    |


---

## 14. select 문장 실행 순서
- FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY  

| 순서  | 절                          | 설명                         |
| --- | -------------------------- | -------------------------- |
| ①   | **FROM**                   | 데이터 소스 지정, 조인 수행 (테이블 읽기)  |
| ②   | **WHERE**                  | 행(Row) 단위 필터링 (집계함수 사용 불가) |
| ③   | **GROUP BY**               | 그룹 단위 생성                   |
| ④   | **HAVING**                 | 그룹 단위 필터링 (집계함수 사용 가능)     |
| ⑤   | **SELECT**                 | 출력 컬럼 및 계산식 평가             |
| ⑥   | **ORDER BY**               | 정렬 수행                      |
| (⑦) | **LIMIT / FETCH / OFFSET** | (DBMS별) 결과 제한              |


---

### JOIN TEST DATA

| ENAME | DEPTNO |  
| ----- | ------ |
| KING  | 10     |
| BLAKE | 30     |
| SMITH | 20     |
| ALLEN | 30     |
| JONES | 40     |

| DEPTNO | DNAME      |
| ------ | ---------- |
| 10     | ACCOUNTING |
| 20     | RESEARCH   |
| 30     | SALES      |
| 50     | HR         |

## 15. Outer join 
- (+) 컬럼이 기준 → 해당 컬럼 NULL 가능  

🔵 **보완**
- **조인 종류**
  - `INNER JOIN`: 교집합 데이터  
  - `LEFT/RIGHT OUTER JOIN`: 기준 테이블 외부 포함  
  - `NATURAL JOIN`: 동일 컬럼명 자동 매칭  
  - `USING`: 동일 컬럼 중 선택적으로 조인

### Left Outer Join
```
SELECT e.ename, e.deptno, d.dname
FROM emp e
LEFT OUTER JOIN dept d
  ON e.deptno = d.deptno;

SELECT e.ename, e.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno(+);
```
| ENAME | DEPTNO | DNAME      |
| ----- | ------ | ---------- |
| KING  | 10     | ACCOUNTING |
| SMITH | 20     | RESEARCH   |
| BLAKE | 30     | SALES      |
| ALLEN | 30     | SALES      |
| JONES | 40     | **NULL**   |

🟢 (+)가 붙은 DEPT가 “외부 테이블”,
EMP가 기준(LEFT 테이블).

### Right Outer Join

```
SELECT e.ename, e.deptno, d.dname
FROM emp e
RIGHT OUTER JOIN dept d
  ON e.deptno = d.deptno;

SELECT e.ename, e.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno(+) = d.deptno;
```
| ENAME    | DEPTNO | DNAME      |
| -------- | ------ | ---------- |
| KING     | 10     | ACCOUNTING |
| SMITH    | 20     | RESEARCH   |
| BLAKE    | 30     | SALES      |
| ALLEN    | 30     | SALES      |
| **NULL** | 50     | HR         |

🟢 (+)가 붙은 EMP가 “외부 테이블”,
DEPT가 기준(오른쪽 테이블).

---

## 16. Inner join 
- 내부 조인

```
SELECT e.ename, e.deptno, d.dname
FROM emp e
INNER JOIN dept d
  ON e.deptno = d.deptno;

SELECT e.ename, e.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno;

```

| ENAME | DEPTNO | DNAME      |
| ----- | ------ | ---------- |
| KING  | 10     | ACCOUNTING |
| SMITH | 20     | RESEARCH   |
| BLAKE | 30     | SALES      |
| ALLEN | 30     | SALES      |


---

## 17. natural join 
- 동일한 이름 갖는 모든 컬럼에 대해 Join (데이터 성격)
```sql
SELECT ~ FROM A NATURAL JOIN B;
```
- 개념
  - 두 테이블에서 동일한 이름을 가진 모든 컬럼을 자동으로 조인 조건으로 사용(타입 반드시 동일)
  - 조인 조건을 명시하지 않아도 자동 매칭
  - 중복 컬럼은 1번만 표시됨
  - ANSI 표준 문법 (Oracle 9i 이상 지원)

| 항목             | 설명                                           |
| -------------- | -------------------------------------------- |
| 조인 조건 직접 지정 불가 | `ON`, `USING` 절 함께 사용 불가                     |
| 컬럼명 자동 매칭      | 동일 이름이 2개 이상이면 모두 조건에 포함                     |
| 모호한 컬럼명 주의     | `deptno`, `loc` 등이 여러 테이블에 존재 시 의도치 않은 결과 가능 |
| 성격             | 내부 조인(INNER JOIN)과 동일                        |

| 항목       | 설명                                                  |
| -------- | --------------------------------------------------- |
| 컬럼명      | 동일해야 함                                              |
| 데이터 타입   | **완전히 일치해야 함** (NUMBER↔NUMBER, VARCHAR2↔VARCHAR2 등) |
| 조인 조건 명시 | 불가능 (자동 결정되기 때문)                                    |
| 변환 필요 시  | `USING` 또는 `ON` 절 사용 후 CAST 필요                      |


---

## 18. Using 조건절
- 같은 이름 컬럼 중 원하는 컬럼만 선택적 Equal Join
```sql
SELECT ~ FROM A JOIN B USING(deptno);

SELECT *
FROM A
JOIN B
USING (col1, col2);

SELECT e.ename, d.dname
FROM emp e
LEFT OUTER JOIN dept d
USING (deptno);
```



| 구분    | NATURAL JOIN       | USING 절               | ON 절                        |
| ----- | ------------------ | --------------------- | --------------------------- |
| 조인 조건 | 자동(동일 이름 컬럼 전체)    | 특정 컬럼 선택              | 명시적 표현                      |
| 문법    | `A NATURAL JOIN B` | `A JOIN B USING(col)` | `A JOIN B ON A.col = B.col` |
| 결과    | 동일 컬럼 1회 표시        | 동일 컬럼 1회 표시           | 중복 표시                       |
| 조인 형태 | INNER JOIN         | INNER JOIN            | INNER JOIN / OUTER JOIN 가능  |

| 구문                                | 내부 동작                                    | 기본 조인 유형   | 설명       |
| --------------------------------- | ---------------------------------------- | ---------- | -------- |
| `USING(col1)`                     | `ON A.col1 = B.col1`                     | INNER JOIN | 단일 컬럼 기준 |
| `USING(col1, col2)`               | `ON A.col1 = B.col1 AND A.col2 = B.col2` | INNER JOIN | 다중 컬럼 기준 |
| `LEFT JOIN ... USING(col1, col2)` | 동일하되 왼쪽 기준                               | LEFT OUTER | 외부 조인 가능 |


---

## 19. Cross Join 
- Product 개념  

🔵 **보완**
- 집합 연산자 `PRODUCT`와 동일 의미  
- 모든 조합 행 생성 (Cartesian Product)

---

## 20. 서브쿼리
- 비연관 → 메인 쿼리와 연관 X  
- 연관 → 메인 쿼리와 연관 O  
- Single Row → 항상 1건  
- Multi Row → 여러건 (`IN`, `ALL`, `ANY`, `EXISTS`)  
- Multi Col → 실행 결과 여러 컬럼
  ```sql
  SELECT ~ 
  FROM ~ 
  WHERE (A, B) IN (SELECT A, B FROM ~);
  ```

🔵 **보완**
- **Inline View**:  
  `FROM` 절 내부의 서브쿼리 → 임시 뷰처럼 활용  
- **뷰(View)**:  
  독립성, 편리성, 보안성 제공  
  ```sql
  CREATE VIEW vw_1 AS SELECT ~;
  DROP VIEW vw_1;
  ```

## 21. 연관 서브쿼리
- 메인 쿼리에 존재하는 모든 행에 반복 수행  

---

## 22. 스칼러 서브쿼리
- 메인 쿼리의 결과 건수만큼 수행  

---

## 23. 뷰 
- 독립성 → 구조 변경 시 응용프로그램 영향 없음  
- 편리성 → 복잡 질의를 단순화  
- 보안성 → 뷰 생성 시 컬럼 선택 가능  

```sql
CREATE VIEW vw_1 AS SELECT ~;
DROP VIEW vw_1;
```

🔵 **보완**
- **Inline View**:  
  `FROM` 절 내부에 SELECT 문을 작성하여 임시 테이블처럼 사용  
- **뷰(View)**는 실제 데이터를 저장하지 않고 쿼리 정의만 저장  

---

## 24. 집합 연산자의 결과 표시 HEADING 부분은 첫 번째
- SQL문에 사용된 ALIAS 적용  
- `INTERSECT` → `EXISTS`, `IN` 으로 대체 가능  

---

## 25. 그룹함수
- `ROLLUP` 함수  
- Grouping column → N → N + 1 (subTotal)  
- 순서 바뀌면 결과 변경, 인수 주의  

🔵 **보완**
| 유형 | 설명 |
|------|------|
| `ROLLUP(A, B)` | A → B 순으로 단계적 그룹화 |
| `CUBE(A, B)` | A, B의 모든 조합 집계 |
| `GROUPING SETS((A), (B))` | 선택적 그룹 집계 |
| `GROUPING(컬럼)` | 소계행은 1, 일반행은 0 반환 |

---

## 26. Grouping 함수
- 소계가 계산된 결과 `GROUPING(Expr)` → 1로 출력, 그 외 결과 0  

---

## 27. Cube 함수
- 다차원 집계  
- 시스템 부담 큼  
- 컬럼 순서 상관 없음  
- 2ⁿ승 결과  

---

## 28. Grouping Sets
- 인수별 개별 집계  
- 순서 변경해도 결과 동일  

---

# 10/13

## 29. 윈도우 함수 
- `RANK()` → 동일 순위 시 다음 순위 건너뜀 (1,2,2,4...)  
- `DENSE_RANK()` → 동일 순위 하나의 건수 (1,2,2,3,4...)  
- `RANGE UNBOUNDED PRECEDING` → 파티션 첫 행부터 현재 행까지  
- `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` → 현재 행 기준 앞뒤 1행씩  
- `RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING` → 값 기준 범위  
- `FIRST_VALUE()` → 파티션별 첫 번째 값  
- `LAST_VALUE()` → 파티션별 마지막 값  
- `LAG()` → 이전 행 참조 (예: `LAG(SAL, 2, 0)`)  
- `LEAD()` → 이후 행 참조 (예: `LEAD(HIREDATE, 1)`)  

🔵 **보완**
| 함수 | 설명 |
|------|------|
| `ROW_NUMBER()` | 유일한 순위 부여 |
| `NTILE(N)` | 전체 행을 N등분 |
| `CUME_DIST()` | 누적 백분율 |
| `PERCENT_RANK()` | 0~1 백분율 순위 |
| `RATIO_TO_REPORT()` | 전체 합 대비 비율 |
- `PARTITION BY`: 그룹핑 유사하지만 행 수 유지  
- `ORDER BY`와 병행 가능  
- `GROUP BY` + 윈도우 함수 동시 사용 가능  

---

## 30. 그룹내 비율 함수 
- `RATIO_TO_REPORT` → 행별 컬럼값의 백분율  
- `PERCENT_RANK` → 0~1 사이 백분율  
- `CUME_DIST` → 누적 백분율  
- `NTILE` → 전체 건수를 N등분  

---

## 31. Top N 쿼리
- `ROWNUM` (Oracle)  
- `TOP` 절 (SQL Server)
  ```sql
  SELECT TOP(2) ~ FROM ~;
  ```
- `ROWNUM`은 **슈도컬럼**으로 사용  

🔵 **보완**
- `WITH TIES`: TOP N에서 동일 순위가 있는 경우 모두 출력  
- 산술 우선순위: `() > ** > *, / > +, -`  

---

## 32. 계층형 질의 
- `START WITH` → 전개 시작 위치  
- `CONNECT BY` → 다음 전개 자식 데이터  
- `PRIOR` → 연결 방향 결정  
  - `fk = PRIOR pk` → 순방향  
  - `pk = PRIOR fk` → 역방향  
- `NOCYCLE` → 순환 발생 시 에러 방지  
- `ORDER SIBLINGS BY` → 형제 노드 간 정렬  
- `LEVEL` → 루트 1, 하위 2, 리프까지 1씩 증가  
- `CONNECT_BY_ISLEAF` → 리프 데이터 여부 (1/0)  
- `CONNECT_BY_ISCYCLE` → 순환 존재 여부  
- `SYS_CONNECT_BY_PATH` → 루트부터 경로 문자열 표시  
- `CONNECT_BY_ROOT` → 루트 데이터 표시  

🔵 **보완**
- `WHERE`는 **계층 구성 후 필터링**  
- SQL Server에서는 **CTE + RECURSIVE**로 구현  
  - `ANCHOR MEMBER`: 최초 집합  
  - `RECURSIVE MEMBER`: 재귀 반복 구성  

---

## 33. pivot 절
```sql
SELECT *
FROM (SELECT JOB, DEPTNO, SAL FROM emp)
PIVOT (SUM(SAL) FOR deptno IN (10,20,30))
ORDER BY 1;
```

🔵 **보완**
- PIVOT은 행 데이터를 열로 변환  
- UNPIVOT은 열 데이터를 행으로 변환  

---

## 34. ACID
- Atomicity 원자성: 성공 또는 전부 실패  
- Consistency 일관성: 트랜잭션 후 데이터 불일치 금지  
- Isolation 격리성: 동시에 실행 시 상호 간섭 없음  
- Durability 영속성: 커밋 후 데이터는 영구 반영  

🔵 **보완**
| 항목 | 설명 |
|------|------|
| Atomicity | 전부 실행 or 전부 실패 |
| Consistency | 데이터 일관성 유지 |
| Isolation | 트랜잭션 간 간섭 차단 |
| Durability | 영구적 반영 |

---

## 35. Commit
- **이전 상태**
  - 변경 취소 가능 (Rollback)  
  - SELECT로 결과 확인 가능  
  - Lock 유지, 타 사용자 변경 불가  
- **이후 상태**
  - 데이터 DB에 반영  
  - 이전 데이터 복구 불가  
  - 모든 사용자에게 반영  
  - Lock 해제, 행 조작 가능  

🔵 **보완**
- `SAVEPOINT`로 특정 시점까지 ROLLBACK 가능  
- DDL(`CREATE`, `DROP`, `TRUNCATE`)은 **자동 커밋 발생**

---

## 36. MSSQL → Auto Commit
- 기본적으로 Auto Commit 모드  

---

## 37. DDL
- `CREATE`, `ALTER`, `DROP`, `RENAME`, `TRUNCATE TABLE`  
- 자동 커밋 (Auto Commit)  
- 중간 접속 단절 시 트랜잭션 롤백  

🔵 **보완**
| 명령어 | 설명 |
|------|------|
| CREATE | 객체 생성 |
| ALTER | 구조 변경 |
| DROP | 삭제 |
| RENAME | 이름 변경 |

---

## 38. create 문 
```sql
CREATE TABLE (
  ~,
  CONSTRAINT player_pk PRIMARY KEY(player_id),
  CONSTRAINT player_fk FOREIGN KEY(team_id) REFERENCES team(team_id)
);
```

🔵 **보완**
```sql
ALTER TABLE Tname ADD CONSTRAINT pk_name PRIMARY KEY(prod_id);
```
- 외래키 제약조건 설정 시 참조 무결성 확보  

---

## 39. NULL
- 아직 데이터가 없는 경우  

---

## 40. Modify column
- 컬럼에 데이터 존재 시 크기 축소 불가 (데이터 훼손 위험)  

🔵 **보완**
```sql
ALTER TABLE 기관분류 
  MODIFY (분류명 VARCHAR2(30) NOT NULL,
          등록일자 DATE NOT NULL);
```

---

## 41. Rename Column
- 컬럼 관련 제약 조건도 자동 변경  

---

## 42. Drop constraint
- `ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명`  

---

## 43. Add constraint
- `ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건(컬럼명)`  

---

## 44. Rename Table
- `RENAME 기존테이블명 TO 새로운테이블명`  
- SQL Server: `sp_rename '기존테이블명', '새로운테이블명'`  

---

## 45. Drop Table
- `DROP TABLE 테이블명 (CASCADE CONSTRAINT)`  

---

## 46. Truncate table
- `TRUNCATE TABLE 테이블명;`  

🔵 **보완**
| 명령어 | 유형 | ROLLBACK | 설명 |
|--------|------|----------|------|
| DELETE | DML | 가능 | 조건부 삭제, 트리거 작동 |
| TRUNCATE | DDL | 불가 | 전체 삭제, 성능 우수 |
| DROP | DDL | 불가 | 객체 자체 삭제 |

---

## 47. MERGE 문
```sql
MERGE INTO t1 a
USING t2 b
ON (a.key = b.key)
WHEN MATCHED THEN UPDATE ...
WHEN NOT MATCHED THEN INSERT ...;
```

## 48. 정규 표현식 (Regular Expression)

- regexp_substr : 정규표현식에 처음 일치하는 부분 문자열 반환 함수

| 연산자 | 영문 | 설명 |
|--------|------|------|
| . | dot | 모든 문자와 일치 |
| \| | or | 대체 문자 구분 |
| \\ | back slash | 다음 문자를 일반 문자로 취급 |

```sql
regexp_substr('aab','a.b') → aab  
regexp_substr('abb','a.b') → abb  
regexp_substr('acb','a.b') → acb  
regexp_substr('adc','a.b') → null
```

| 연산자 | 영문 | 설명 |
|--------|------|------|
| ^ | carrot | 문자열 시작 |
| $ | dollar | 문자열 끝 |
| ? |  | 0 회 또는 1회 일치 |
| * |  | 0 회 또는 그 이상 횟수 |
| + |  | 1 회 또는 그 이상 횟수 |
| {m} |  | m 회 일치 |
| {m,} |  | 최소 m 회 |
| {,m} |  | 최대 m 회 |
| {m,n} |  | 최소 m, 최대 n 회 |

```sql
regexp_substr('ac','ab?c') → ac  
regexp_substr('abc','ab?c') → abc  
regexp_substr('abbc','ab?c') → null  
regexp_substr('ac','ab*c') → ac  
regexp_substr('abc','ab+c') → abc  
```

| 연산자 | 설명 | 동일 |
|--------|------|------|
| [:digit:] | 숫자 | [0-9] |
| [:lower:] | 소문자 | [a-z] |
| [:upper:] | 대문자 | [A-Z] |
| [:alpha:] | 영문자 | [a-zA-Z] |
| [:alnum:] | 영문자 + 숫자 | [0-9a-zA-Z] |
| [:xdigit:] | 16진수 | [0-9a-fA-F] |

```sql
regexp_substr('gF1,','[[:digit:]]') → 1  
regexp_substr('gF1,','[[:alpha:]]') → g  
regexp_substr('gF1,','[[:upper:]]') → F  
```

| 연산자 | 설명 | 동일 |
|--------|------|------|
| \d | 숫자 | [[:digit:]] |
| \D | 숫자가 아닌 문자 | [^[:digit:]] |
| \w | 영문자 또는 숫자 | [[:alnum:]_] |
| \W | 영문자·숫자 아닌 문자 | [^[:alnum:]_] |
| \s | 공백 문자 | [[:space:]] |
| \S | 공백 아닌 문자 | [^[:space:]] |

```sql
regexp_substr('(650) 555-0100','^\(\d{3}\)\s\d{3}-\d{4}$') → (650) 555-0100  
regexp_substr('b2b','\w\d\D') → b2b  
regexp_substr('jdoe@company.co.uk','\w+@\w+(\.\w+)+') → jdoe@company.co.uk  
```

| 연산자 | 설명 |
|--------|------|
| ?? | 0회 또는 1회 일치 |
| *? | 0회 이상(비탐욕) |
| +? | 1회 이상(비탐욕) |
| {m}? | m 회 일치 |
| {m,n}? | 최소 m, 최대 n 회 일치 |

🔵 **보완**
- 주요 정규 함수  
  | 함수 | 설명 |
  |------|------|
  | `REGEXP_LIKE(expr, pattern)` | 패턴과 일치 하면 TRUE |
  | `REGEXP_SUBSTR(expr, pattern)` | 일치 부분 문자열 추출 |
  | `REGEXP_REPLACE(expr, pattern, rstr)` | 일치 부분을 rstr로 치환 |
  | `REGEXP_INSTR(expr, pattern)` | 일치 패턴의 위치 반환 |
  | `REGEXP_COUNT(expr, pattern)` | 패턴 출현 횟수 반환 |
- 정규식은 패턴 매칭, 데이터 검증, 문자열 치환 등에 활용  
- Oracle 과 SQL Server 모두 지원하나 함수 명칭은 상세 차이 존재  

---

## 49. 기타 유용 SQL 요약 (보완 중심 섹션)

🔵 **보완**
- **NULL 연산 규칙**  
  - `NULL + 숫자 = NULL`, `NULL + 문자 = NULL`  
  - 비교 연산 불가 → `IS NULL`, `IS NOT NULL` 사용  
  - 오라클에서는 `''` 빈 문자열도 NULL 로 간주  
- **DATE 연산**  
  - 날짜 + 숫자 → 일(day) 단위 계산  
  - `1/24` = 1시간, `1/24/60` = 1분  
  - `SYSDATE` (Oracle), `GETDATE()` (SQL Server) 함수  
- **권한 관리**  
  - `WITH GRANT OPTION`: 권한 재부여 가능  
  - `REVOKE WITH GRANT OPTION`: 연쇄 회수  
- **테이블 명명 규칙**  
  - 의미 있는 단수형 사용, 예약어 또는 중복 피하기  
- **WITH TIES** 옵션  
  - TOP N 조회 시 동일 순위 행 모두 출력  

---

📘 **정리 요약**

| 대분류 | 핵심 내용 |
|---------|-----------|
| SQL 기본 문법 | DML/DDL/DCL/TCL 명령 및 집합 연산자 |
| 그룹·윈도우 함수 | ROLLUP/CUBE/GROUPING 및 RANK, LAG, LEAD |
| 트랜잭션 관리 | ACID 원칙, COMMIT/ROLLBACK, Auto Commit |
| 제약조건 및 DDL | CREATE, ALTER, DROP, RENAME, FOREIGN KEY |
| 정규표현식 활용 | 패턴 매칭 및 문자열 검증, REGEXP_ 함수 |
| 기타 | NULL/DATE 처리, 권한, 테이블 명명 규칙 |
